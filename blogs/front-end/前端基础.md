---
title: 前端基础
date: 2019-06-03
categories:
- Front-End
tags:
- Front-End
---

## 1.CSS

### 1.1CSS基础语法

#### 1.1.1CSS声明

**单个CSS声明**：

![image-20210117205525330](/static/img/image-20210117205525330.png)

**多个CSS声明**：

采用CSS声明块

![image-20201015152057724](/static/img/image-20201015152057724.png)

#### 1.1.2CSS规则

**CSS规则**：CSS选择器+CSS声明块

![image-20201015152531167](/static/img/image-20201015152531167.png)

练习：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CSS声明</title>
    <!--style标签用于定义样式信息-->
    <style>
    /*CSS选择器用于定位需要修饰的元素，此处为p标签*/    
        p {
            /*设置字体颜色*/
            color: darkcyan;
            /*设置背景颜色*/
            background-color: lightcoral;
        }
    </style>
</head>
<body>
    <p>这是一个段落</p>
</body>
</html>
```

#### 1.1.3CSS的三种引入方式

- 行内样式

  每个标签都有一个`style`属性用于设置CSS样式

  ```html
  <p style="color:darkcyan;font-weight: bold;">这是一个段落</p>
  ```

- 内部样式表

  通过`<head>`标签下的 `<style>`标签来设置CSS样式

  ```html
  <head>
     <style type="text/css">
          p {
              color: darkcyan;
              background-color: lightcoral;
          }
      </style>
  </head>
  ```

- 外部样式表

  使用html代码引用外部文件扩展名为.css的样式表来设置CSS样式

  ```css
  /*demo.css*/
  p {
      color: darkcyan;
      background-color: lightcoral;
  }
  ```

  1. 链接式
     语法：`<link type="text/css" rel="styleSheet" href="CSS文件路径" />`

     ```html
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <title>CSS引入方式</title>
         <!--type属性表示当前链接的文件式css类型的文本，rel属性表示当前链接的文件为一个样式表，href属性表示文件路径-->
         <link type="text/css" rel="stylesheet" href="demo.css">
     </head>
     <body>
         <p>这是一个段落</p>
     </body>
     </html>
     ```

  2. 导入式

     语法：`<style type="text/css">  @import url("CSS文件路径");</style>`

     ```html
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <title>CSS引入方式</title>
         <style>
             @import url("demo.css");
         </style>
     </head>
     <body>
         <p>这是一个段落</p>
     </body>
     </html>
     ```

**引入方式优先级**：当同时使用了行内样式，外部样式表，内部样式表对一个标签设置CSS样式，**优先级为内部样式>外部样式表=内部样式表**，此时呈现的样式应为内部样式定义的CSS

### 1.2CSS选择器

#### 1.2.1**四种常见选择器**

- **ID选择器**

  语法：`#ID名`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
          /*#p1为ID选择器，选定id名为p1的标签*/
          #p1{
              color: darkcyan;
          }
      </style>
  </head>
  <body>
     <p id="p1">这是一个段落</p>
  </body>
  </html>
  ```

- **元素选择器**

  语法：`标签名`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
          /*p为元素选择器，选定标签名为p的所有标签*/
          p{
              color:salmon;
          }
      </style>
  </head>
  <body>
     <p>这是一个段落2</p>
  </body>
  </html>
  ```

- **类选择器**

  语法：`.类名`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
         /*.p3为类选择器，选定类名为p3的所有标签*/
          .p3{
              color:aquamarine;
          }
      </style>
  </head>
  <body>
     <p class="p3">这是一个段落3</p>
  </body>
  </html>
  ```

- **属性选择器**

  语法：`[属性名]`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
         /*[title]为属性选择器，选定带有属性title的所有标签*/        
          [title]{
              color:aquamarine;
          }
      </style>
  </head>
  <body>
     <p title="段落">这是一个段落4</p>
  </body>
  </html>
  ```

#### 1.2.2伪类

用于向某些选择器添加特殊效果

![image-20201015164421258](/static/img/image-20201015164421258.png)

语法：`CSS选择器 伪类{}`

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CSS选择器</title>
    <style>
        a:hover{
            background-color:black;
        }
        a:link{
            color: darkcyan;
        }
        a:visited{
            color:sienna;
        }
        /*鼠标点击不放时，字体颜色会变化*/
        a:active{
            color:lightcoral;
        }
    </style>
</head>
<body>
    <a href="#">这是一个链接</a>
</body>
</html>
```

#### 1.2.3伪元素

用于向某些选择器设置特殊效果

- `::before`：可以在当前元素之前插入新内容

- `::after`：可以在当前元素之后插入新内容

  语法：`CSS选择器 伪元素{}`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
          /*在p标签前插入一个双引号*/
          p::before{
              content: '"';
              color:green;
          }
          /*在p标签后插入一个双引号*/
          p::after{
              content: '"';
              color: green;
          }
      </style>
  </head>
  <body>
     <p>这是一个段落</p>
  </body>
  </html>
  ```

#### 1.2.4CSS选择器的优先级

在外部样式表和内部样式表中：使用不同方式的CSS选择器定位同一个标签来设置CSS样式，**优先级为ID选择器>类选择器>属性选择器>伪类>元素选择器>伪元素选择器**

`!important`会将当前选择器设置的CSS样式优先级放至第一位

语法：`CSS选择器{样式属性:样式值!important}`

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>CSS声明</title>
    <style>
        /*类选择器*/
        .p1{
            color:darkcyan;
        }
        /*元素选择器*/
        p{
            color:lightcoral!important;/*由于color样式属性被设置为!important最高优先级，所以此时应该是元素选择器的color属性生效
        }
    </style>
</head>
<body>
   <p class="p1">这是一个段落</p>
</body>
</html>
```

#### 1.2.5基于关系的选择器

- **后代元素选择器**：可以定位标签A下的任一子标签或子孙标签E

  语法：`A E`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
          /*div span为后代元素选择器，定位div标签下所有的span标签*/
          div span{
              color: red;
          }
          /*定位所有的span的标签*/
          span{
              color:blue;
          }
      </style>
  </head>
  <body>
      <!--div标签下的所有span标签为红色-->
     <div>
         <span>span1
             <span>
                 span2
             </span>
         </span>
     </div>
     <!--div外的span标签为蓝色-->
     <span>span3</span>
  </body>
  </html>
  ```

- **子元素选择器**：可以定位标签A的任一直系子标签E，不包含子孙标签

  语法：`A>E`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
          span{
              color:blue;
          }
          /*div>span为子元素选择器，定位div标签下的span标签，但不定位span标签中的span标签*/
          div>span{
              color: red;
          }
      </style>
  </head>
  <body>
     <div>
         <!--span1为红色-->
         <!--span2和span3为蓝色-->
         <span>span1
             <span>
                 span2
             </span>
         </span>
     </div>
     <span>span3</span>
  </body>
  </html>
  ```

- **相邻元素选择器**：可以定位标签A的下一个相邻兄弟标签E

  语法：`A+E`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS选择器</title>
      <style>
         	/*#one+li为相邻元素选择器，定位id为one的标签的下一个兄弟标签，即第二个li标签*/
          #one+li{
              color:green;
          }
      </style>
  </head>
  <body>
     <div>
         <ul>
             <li id="one">第一</li>
             <!--第二字体为绿色-->
             <li>第二</li>
             <li>第三</li>
         </ul>
     </div>
  </body>
  </html>
  ```

### 1.3CSS样式

**背景**：![image-20201015210142578](/static/img/image-20201015210142578.png)

- **表格**：

  ![image-20201015212313177](/static/img/image-20201015212313177.png)

- **文本**：

  ![image-20201015215102001](/static/img/image-20201015215102001.png)

- **字体**：

  ![image-20201015215838017](/static/img/image-20201015215838017.png)

  引入自定义的字体

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS样式</title>
      <style>
          /*使用@font-face引入外部字体文件*/
        @font-face {
            /*此处font-family用于给自定义字体命名*/
          font-family: "potato";
            /*设置外部字体文件的路径和格式化方式*/
            /*多个字体文件是为了电脑能更好的兼容*/
          src: url("FZ1.TTF") format("truetype");
          src: url("FZ2.TTF") format("truetype");
            /*设置字体粗细*/
          font-weight:400;
            /*设置字体风格*/
          font-style: italic;
        }
        p{
            /*使用自定义的字体系列*/
          font-family: potato;
        }
      </style>
  </head>
  <body>
    <p>这是一个段落</p>
  </body>
  </html>
  ```

- **列表**

  ![image-20201015233056881](/static/img/image-20201015233056881.png)

### 1.4CSS浮动

**HTML的文档流**：文档流就是在浏览器中的规则，块级元素的规则是从上到下排序的，行内元素是从左到右排序的

**HTML的文本流**：文本（包括图片）的排列规则

**CSS浮动**：使元素脱离文档流，浮动在文档流上层，但不脱离文本流。即文档流中的块级元素和行内元素会对浮动的元素视而不见，占据浮动元素的下方空间，但文本会看得到浮动的元素，并在浮动元素周围排列

**CSS浮动规则**：

- CSS的浮动会使行内元素变为块级元素，使得行内元素的宽高可控
- 多个元素都设置为左浮动或右浮动，则多个元素都会一个挨着一个向左排列或向右排列，直到自己的边界紧贴着包含块（父元素）或者其他的浮动元素的边界为止
- 浮动元素不能与行内元素的内容层叠，行内元素的内容将会被浮动元素推出去
- 浮动元素若没有设置宽高，则默认宽高为浮动元素的内容宽高

**float四个参数介绍**：

- `float:left`：设置元素左浮动
- `float:right`：设置元素右浮动
- `float:none`：不浮动
- `float:inherit`：继承父级元素的浮动属性

**CSS浮动的影响及解决方法**：

**高度坍塌**：父元素不写高，靠子元素撑起高度，当所有子元素都浮动，那么所有子元素都脱离文档流，父元素认为自己内部没有元素了

所以父元素就没有高度了。

**解决方法**：

- **浮动父元素（会影响后续不浮动的元素）**

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <style>
          .father{
              width: 500px;
              height: auto;/*设置高度自动，即靠子元素的高度撑起*/
              border: solid ;
              float: left;
          }
          .test{
              width: 250px;
              height: 50px;
              background-color: red;
              float: left;
          }
      </style>
  </head>
  <body>
  <div class="father">
      <div class="test"></div>
      <div class="test"></div>
  </div>
  </body>
  </html>
  ```

- **给父元素手动设置高度（并不是每次都能知道具体高度多少）**

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <style>
          .father{
              width: 500px;
              height: 50px;
              border: solid ;
          }
          .test{
              width: 250px;
              height: 50px;
              background-color: red;
              float: left;
          }
      </style>
  </head>
  <body>
  <div class="father">
      <div class="test"></div>
      <div class="test"></div>
  </div>
  </body>
  </html>
  ```

- **设置`overflow:hidden`属性（可能会导致溢出内容被隐藏）**：

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <style>
          .father{
              width: 500px;
              height: auto;
              border: solid ;
              /*overflow:hidden用于隐藏溢出边框的内容，该属性会具体计算元素的宽高，即使子元素float也会将其宽高计算*/
              overflow: hidden;
          }
          .test{
              width: 250px;
              height: 50px;
              background-color: red;
              float: left;
          }
      </style>
  </head>
  <body>
  <div class="father">
      <div class="test"></div>
      <div class="test"></div>
  </div>
  </body>
  </html>
  ```

- **在父元素中追加一个无内容无高度的块级元素并设置属性clear:both（代码不美观）**：

  **clear属性参数介绍：**

  - `clear:left`：在该元素的左侧不允许有浮动元素
  - `clear:right`：在该元素的右侧不允许有浮动元素
  - `clear:both`：在该元素的左右两侧不允许有浮动元素
  - `clear:inherit`：继承父级元素的clear属性
  - `clear:none`：允许元素左右两侧有浮动元素

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <style>
          .father{
              width: 500px;
              height: auto;
              border: solid ;
          }
          .test{
              width: 250px;
              height: 50px;
              background-color: red;
              float: left;
          }
          .clear{
              clear: both;/*设置左右两侧不能有浮动元素，所以这个div元素一定会被排在最大高度处，由于自身没有高度，所以父级元素就能知道高度为多少*/
          }
      </style>
  </head>
  <body>
  <div class="father">
      <div class="test"></div>
      <div class="test"></div>
      <div class="clear"></div>
  </div>
  </body>
  </html>
  ```

- **采用伪类`:after`**：

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
      <style>
          .father{
              width: 500px;
              height: auto;
              border: solid ;
          }
          .test{
              width: 250px;
              height: 50px;
              background-color: red;
              float: left;
          }
          /*在父元素形成后，在父元素的结尾插入一个空白字符并设置为块级元素，同时不允许字符两侧有浮动元素，所以该字符一定在最大高度处，这样父级元素就能知道高度为多少了*/
          .father:after{
              display: block;
              content: "";
              clear: both;
          }
      </style>
  </head>
  <body>
  <div class="father">
      <div class="test"></div>
      <div class="test"></div>
  </div>
  </body>
  </html>
  ```



### 1.5CSS布局

块级元素在不设置宽度的情况下会独占浏览器的一行，按照代码的声明顺序从上到下垂直排列

- **两行三列布局**

  ![image-20201016001139559](/static/img/image-20201016001139559.png)

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
    <style>
      body{
        margin:0;
      }
      header{
        background-color: yellow;
        height: 200px;/*第一行高度*/
      }
      div{
        background-color: black;
        height: 560px;/*第二行高度*/
      }
      nav{
        background-color: red;
        width: 150px;/*第一列宽度*/
        height: 100%;/*高度设置为父标签div的100%高度*/
        float: left;/*设置左浮动*/
      }
      /*由于aside和nav标签都左右浮动，所以article标签会自动向上，顶在header下方，形成三列的效果*/
      article{
        background-color: green;
        height: 100%;/*高度设置为父标签div的100%高度*/
      }
      aside{
        background-color: blue;
        width: 150px;/*第三列宽度*/
        height: 100%;/*高度设置为父标签div的100%高度*/
        float: right;/*设置右浮动*/
      }
    </style>
  </head>
  <body>
  <!--标签header组成第一行-->
  <header></header>
  <!--标签div组成第二行-->
  <div>
    <!--标签nav组成第一列-->
    <nav></nav>
    <!--标签aside组成第三列-->  
    <aside></aside>
    <!--标签article组成第二列-->  
    <article></article>
  </div>
  </body>
  </html>
  ```

- **三行两列布局**

  ![image-20201016003106586](/static/img/image-20201016003106586.png)

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
    <style>
      body{
        margin:0;
      }
      header{
        background-color: red;
        height: 150px;
        margin: 0;
      }
      div{
        background-color:green;
        height: 460px;
      }
      footer{
        background-color:blue;
        height: 150px;
      }
      nav{
        background-color: yellow;
        width: 200px;
        height: 100%;
        float: left;
      }
      article{
        background-color: black;
        height: 100%;
        margin-left: 200px;/*由于nav标签左浮动，所以设置外边距为nav标签的宽度，防止两元素重合*/
      }
    </style>
  </head>
  <body>
  <!--标签header组成第一行-->
  <header></header>
  <!--标签div组成第二行-->
  <div>
  <!--标签nav组成第一列-->
    <nav></nav>
    <!--标签article组成第二列-->  
    <article></article>
  </div>
  <!--标签footer组成第三行-->
  <footer></footer>
  </body>
  </html>
  ```

### 1.6CSS布局应用

```html
<!--demo.html-->
<!--该网页分为头部，主体，尾部三部分，主体又可以再分为上，中，下三部分-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!--引用外部样式表-->
    <link type="text/css" rel="stylesheet" href="demo.css">
</head>
<body>
    <!--设置头部-->
    <header>
        <div class="logo">
            <img src="image/logo.png" alt="logo">
        </div>
        <div class="nav">
            <ul>
                <li>手记</li>
                <li>视频</li>
                <li>图片</li>
                <li>首页</li>
            </ul>
        </div>
    </header>
    <!--设置主体-->
    <div class="main">
        <!--设置主体的上部分-->
        <div class="top">
            <div class="shade"></div>
            <img src="image/1.jpeg" alt="风景">
            <div class="top-content">
                <div class="word">MY BEAUTIFUL LIFE</div>
                <button>LOOK MORE ></button>
            </div>
        </div>
        <!--设置主体的中部分-->
        <div class="mid">
            <div class="m-top">
                <div class="app">
                    <img class="app-img" src="image/weibo.png" alt="weibo">
                    <div class="app-name">MICROBLOG</div>
                </div>
                <div class="app">
                    <img class="app-img" src="image/QQ.png" alt="qq">
                    <div class="app-name">QQ</div>
                </div>
                <div class="app">
                    <img class="app-img" src="image/weixin.png" alt="weixin">
                    <div class="app-name">WECHAT</div>
                </div>
            </div>
            <div class="m-mid">
                "I want to give good things to record down,
                <br>
                after the recall will be very beautiful."
            </div>
            <div class="m-bottom">
                <div class="scene">
                    <img class="picture" src="image/03-01.jpg" alt="背景图">
                    <div class="desc1">Cool Image</div>
                    <div class="desc2">Record The Picture</div>
                </div>
                <div class="scene">
                    <img class="picture" src="image/03-02.jpg" alt="背景图">
                    <div class="desc1">Great Picture</div>
                    <div class="desc2">The Picture</div>
                </div>
                <div class="scene">
                    <img class="picture" src="image/03-03.jpg" alt="背景图">
                    <div class="desc1">Cool Image</div>
                    <div class="desc2">Record The Picture</div>
                </div>
            </div>
        </div>
        <!--设置主体的下部分-->
        <div class="bottom">
            <div class="title">
                FROM THE PHOTO ALBUM
            </div>
            <div class="content">
                <div class="album">
                    <img  class="album-img" src="image/04-01.jpg" alt="背景图">
                    <div class="album-content">
                        Life is like a book, just read more and more<br>refined, more write more carefully. When<br>read, mind open, all things have been<br>to heart. Life is the precipitation.
                    </div>
                </div>
                <div class="album">
                    <img  class="album-img" src="image/04-02.jpg" alt="背景图">
                    <div class="album-content">
                        Life is like a cup of tea, let people lead a<br>person to endless aftertastes. You again good<br>taste,it will always have a different taste,<br>different people will have different taste<br>more.
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!--设置尾部-->
    <footer>
        © 2016 imooc.com 京ICP备13046642号
    </footer>
</body>
</html>
```

```css
/*demo.css*/
*{
    margin:0;
    padding: 0;
}
html,body{
    width: 100%;
    height: 100%;
    box-sizing: border-box;
}
header{
    width:100%;
    height: 100px;
}
.logo{
    float: left;
}
.logo img{
    width:300px;
    height: 85px;
    padding-left:100px;
    padding-top:8px ;
}
.nav{
    float: right;
}
.nav ul{
    margin-right: 100px;
}
.nav ul li{
    color: #7D7D7D;
    width: 80px;
    height: 100px;
    font-size:15px ;
    list-style: none;
    font-weight: bolder;
    float: left;
    line-height: 100px;
}

.main{
    width: 100%;
    height: auto;
}
/*shade类的标签用于设置遮罩层*/
.shade{
    /*设置绝对定位，脱离了文档流*/
    position: absolute;
    background-color:#000000;
    width: 100%;
    height: 600px;
    /*opacity属性用于设置透明度，通过元素重叠，将上层的透明化，实现遮罩的效果*/
    opacity: 0.5;
}
.top img{
    width: 100%;
    height: 600px;
}
.top-content{
    /*设置绝对定位，相对于窗口偏移*/
    position: absolute;
    width: 500px;
    height: 300px;
    top:50%;
    left: 50%;
    margin-top: -180px;
    margin-left: -250px;
    font-weight: bolder;
    text-align: center;
}
.word{
    width: 500px;
    height: 160px;
    color: #FFFF;
    font-size: 45px;
    line-height: 160px;
}
.top-content button{
    width: 200px;
    height: 60px;
    background-color: #F5704F;
    color: #FFFF;
    font-size: 15px;
    line-height: 60px;
    margin:0 150px;
    border-radius: 8px;
}
.mid{
    width: 1000px;
    height: auto;
    margin: 0 auto;
}
.m-top{
    width: 100%;
    height: auto;
}
/*消除子元素浮动带给父元素的高度坍塌问题*/
.m-top::after{
    display: block;
    content:"";
    clear:both;
}
.app{
    width: 33.3%;
    height: auto;
    float: left;
}
.app-img{
    width:100px ;
    height: 100px;
    padding-top: 50px;
    padding-left: 100px;
}
.app-name{
    color: #7D7C7F;
    font-size: 20px;
    font-weight: bold;
    padding-top: 20px;
    padding-right:40px;
    text-align: center;
}
.m-mid{
    color:#E19796;
    text-align: center;
    font-weight: bolder;
    font-size: 22px;
    font-style: italic;
    /*左右居中*/
    margin: 50px auto;
}
.m-bottom{
    width: 100%;
    height: auto;
}
/*消除子元素浮动带给父元素的高度坍塌问题*/
.m-bottom::after{
    display: block;
    content:"";
    clear:both;
}
.scene{
    width: 33.3%;
    height: auto;
    float: left;
    padding-bottom: 20px;
    font-size: 20px;
    font-weight: bolder;
    text-align: center;
}
.picture{
    width: 310px;
    height: 260px;
}
.desc1{
    color:#7D7D7F;
    margin-top: 20px;
    margin-bottom: 10px;
}
.desc2{
    color: #BDBDBC;
}
.bottom{
    width: 100%;
    height: auto;
    background-color: #F9F9F9;
}
.title{
    color: #7D7C7F;
    text-align: center;
    padding-top: 50px;
    padding-bottom: 50px;
    font-weight: bolder;
    font-size: 20px;
}
.content{
    width: 1000px;
    height: auto;
    /*左右居中*/
    margin: 0 auto;
    padding-bottom:50px;

}
/*消除子元素浮动带给父元素的高度坍塌问题*/
.content::after{
    display: block;
    content:"";
    clear:both;
}
.album{
    width: auto;
    height: auto;
    float: left;
    margin-right: 20px;
}
.album-img{
    width: 470px;
    height: 460px;

}
.album-content{
    color: #7D7C7F;
    font-size: 20px;
    font-weight: bolder;
}
footer{
    width: 100%;
    height: 100px;
    background-color: #292C35;
    color: #FFFF;
    text-align: center;
    line-height: 100px;
    font-size: 15px;
}
```

### 1.7CSS盒子模型

每一个可见的 HTML 元素都是一个盒子，盒子由**margin（外边距）**、**border（边框）**、**padding（内边距）**、**content（内容）**组成，

**margin**、**border**、**padding**是CSS属性，而且**content**则是HTML元素的内容。

![image-20201016005411840](/static/img/image-20201016005411840.png)

默认的width属性和height属性指的都是内容区的宽和高

**盒子的宽度** = 内容宽度 + 左填充 + 右填充 + 左边框 + 右边框 + 左边距 + 右边距

**盒子的高度** = 内容高度 + 上填充 + 下填充 + 上边框 + 下边框 + 上边距 + 下边距

- **边框**：![image-20201016005636034](/static/img/image-20201016005636034.png)

- **内边距**：

  ![image-20201016005728402](/static/img/image-20201016005728402.png)

- **外边距**：

  ![image-20201016005756699](/static/img/image-20201016005756699.png)

### 1.8CSS定位模型

- **偏移属性（仅对非静态定位模型生效）**：
  
  - `left:偏移值`：距左边多少像素，即向右偏移，当偏移值为负时，为向左偏移
  - `right:偏移值`：距右边多少像素，即向左偏移，当偏移值为负时，为向右偏移
  - `top:偏移值`：距上边多少像素，即向下偏移，当偏移值为负时，为向上偏移
  - `bottom:偏移值`：距下边多少像素，即向上偏移，当偏移值为负时，为向下偏移
- `z-index:value`：value为一个整数值，当两元素重叠时，`z-index`的值越大的元素会覆盖在上方
  
- **静态定位模型**

  - 作用：使元素定位于HTML文档流中，即块级元素从左到右排列，行内元素从上到下排列

  - 特点：

    1. 会忽略top，bottom，right，left和z-index的声明，即无法对其进行偏移
    2. 两个相邻的元素都设置了外边距，则两个外边距会合并，最终外边距的值为两者外边距中最大的一个
    3. 具有固定width和height值的元素，若将其左右外边距设置为auto，则该元素的左右外边距会自动扩大占满剩余宽度，即该元素会左右居中

  - 语法：`position:static`（没有设置position属性时，默认元素为静态定位模型）

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <style>
            .div1{
                width: 100px;
                height: 100px;
                margin: 10px;/*div1外边距为10px，div1距div2为20px，div1的10px合并到了div2的外边距中*/
                border: solid;
            }
            .div2{
                width: 100px;
                height: 100px;
                margin: 20px;/*div2的外边距为20px*/
                border: solid;
            }
            .div3{
                width: 100px;
                height: 100px;
                margin: 0px auto;/*具有具体宽高的div3左右外边距为自动，形成左右居中的效果*/
                border: solid;
            }
        </style>
    </head>
    <body>
    <div class="div1"></div>
    <div class="div2"></div>
    <div class="div3"></div>
    </body>
    </html>
    ```

- **相对定位模型**

  - 作用：使元素成为可定位的祖先元素

  - 特点：

    1. 可以使用top，bottom，right，left和z-index的声明，使该元素相对于原位置产生偏移
    2. 相对定位的元素不会脱离HTML文档流，即元素即使发生偏移，原位置所占据的空间依旧存在
    3. 任何元素都可以设置为相对定位，它的绝对定位的后代都可以相对于它进行绝对定位
    4. 可以使浮动的元素发生偏移，并控制他们的堆叠顺序

  - 语法：`position:relative`

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <style>
            .div1{
                width: 100px;
                height: 100px;
                border: solid;
            }
            .div2{
                left:100px;/*向右移100px*/
                position: relative;/*设为相对定位模型*/
                width: 100px;
                height: 100px;
                border: solid;
            }
            /*即使div2右移，但其并未脱离文档流，所以空间依旧存在，div3并不会占据其位置*/
            .div3{
                width: 100px;
                height: 100px;
                border: solid;
            }
            .div4{
                position: relative;/*设为相对定位模型*/
                width: 100px;
                height: 100px;
                border: solid;
                float: right;/*右浮动*/
                z-index: 1;/*设置重叠顺序*/
            }
            .div5{
                position: relative;/*设为相对定位模型*/
                right: -104.8px;/*相对定位模型可以控制浮动元素的偏移，向右移104.8px，与div4重叠*/
                width: 100px;
                height: 100px;
                border: solid red;
                float: right;/*右浮动*/
                z-index: 0;/*由于div5的z-index值小于div4，所以div4显示在div5的上方*/
            }
        </style>
    </head>
    <body>
    <div class="div1"></div>
    <div class="div2"></div>
    <div class="div3"></div>
    <div class="div4"></div>
    <div class="div5"></div>
    </body>
    </html>
    ```

- **绝对定位模型**

  - 作用：使元素脱离HTML文档流

  - 特点：

    1. 脱离HTML文档流
    2. 元素设置尺寸涉及百分比时或者元素偏移时，相对的是都最近定位祖先元素（如果没有最近定位祖先元素，则默认是body标签）
    3. left，right，top，bottom都为设为0时，将元素的左右上下外边距设为自动，可以实现元素的上下居中和左右居中
    4. left，right，top，bottom都为auto时，元素会回到HTML文档流中

  - 语法：`position:absolute`

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <style>
            .div1{
                width: 100px;
                height: 100px;
                border: solid;
            }
            .div2{
                left:104.8px;
                position: absolute;/*设为绝对定位模型*/
                width: 50%;/*由于div2没有最近定位祖先元素，所以以body标签宽的50%作为div2的宽度*/
                height: 100px;
                border: solid;
            }
            /*由于div2为绝对定位，脱离html文档流，所以div3会占据div2原有的空间*/
            .div3{
                width: 100px;
                height: 100px;
                border: solid;
            }
           /*设为son的最近定位祖先元素*/
            .father{
                position: relative;/*设为相对定位模型*/
                width: 500px;
                height: 500px;
                border: solid;
            }
            .son{
                width: 100px;
                height: 100px;
                position: absolute;/*设为绝对定位模型*/
                /*上下左右偏移量全设为0*/
                left: 0;
                right:0;
                top: 0;
                bottom: 0;
                /*由于元素距上下左右的距离都为0，所以当外边距为自动时，会自动对上下左右进行填充，直至碰到的边界为止，此时会形成元素上下居中，左右居中的效果*/
                margin: auto auto;
                border: solid;
            }
             .son2{
                width: 100px;
                height: 100px;
                position: absolute;/*设为绝对定位模型*/
                /*由于最近定位祖先元素为father，所以元素距有边界为0像素，即元素距father右边界为0像素*/
                right: 0;
                border: solid;
            }  
        </style>
    </head>
    <body>
    <div class="father">
        <div class="son"></div>
        <div class="son2"></div>
    </div>
    <div class="div1"></div>
    <div class="div2"></div>
    <div class="div3"></div>
    </body>
    </html>
    ```

- **固定定位模型**

  - 作用：使元素脱离HTML文档流

  - 特点：

    1. 脱离HTML文档流
    2. 元素设置尺寸涉及百分比时或者元素偏移时，相对的是浏览器可见的窗口界面，即元素不会随着浏览器界面滚动而滚动
    3. left，right，top，bottom都为设为0时，将元素的左右上下外边距设为自动，可以实现元素的上下居中和左右居中
    4. left，right，top，bottom都为auto时，元素会回到HTML文档流中

  - 语法：`position:fixed`

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <style>
            body{
                height: 1000px;/*设置body的高为1000px，使窗口出现滚动条，当窗口滚动向下*/
            }
          .div1{
              position: fixed;/*设置固定定位模型，脱离HTML文档流*/
              left: 0;
              right: 0;
              top: 0;
              bottom: 0;
              margin: auto;/*同绝对定位原理相同*/
              width: 100px;
              height: 50%;/*此处高度为窗口高度的50%，而非body的高度*/
              border: solid;
          }
        </style>
    </head>
    <body>
    <!--当窗口滚动向下，div1始终相对于窗口，处在中央，不会随窗口的滚动而滚动-->
    <div class="div1"></div>
    </body>
    </html>
    ```

- **粘性定位模型**

  - 作用：相当于relative和fixed定位模型的结合，制造出吸附效果
  
  - 特点：
    
    1. 如果产生偏移，原位置还在HTML文档流中
    2. 如果最近祖先元素有滚动条，那么元素的偏移就相对于最近祖先元素
    3. 如果最近祖先元素没有滚动条，那么元素的偏移就相对于浏览器可见的窗口界面
    4. 当页面滚动，父元素开始脱离视口时（即部分不可见），只要与`sticky`元素的距离达到生效门槛，`relative`定位自动切换为`fixed`定位；等到父元素完全脱离视口时（即完全不可见），`fixed`定位自动切换回`relative`定位。
    
  - 语法：`position:sticky`
  
    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
        <style>
            *{
                margin:0;
                padding: 0;
                box-sizing: border-box;
            }
            body{
                height: 5000px;/*设置body较高的高度，使浏览器出现滚动条*/
            }
            /*设置nav的父元素*/
            .father{
                height: 300px;
                border: solid;
                /*当设置了overflow:scroll;则nav的偏移会相对于father*/
            }
            .nav{
                /*设置粘性模型*/
                position: sticky;
                /*由于父元素father没有滚动条，所以nav相对于浏览器视窗偏移，即距离视窗顶部0px*/
                /*当页面滚动，nav元素距视窗为0px时，会变为fixed定位模型，直到父元素被滚出视窗外不可见，才会变回relative定位模型*/
                top:0;
                background-color: #000000;
                width: 25%;
                height: 100px;
                border: solid;
                float: left;
                font-size: 20px;
                font-weight: bolder;
                color:white;
                line-height: 100px;
                text-align: center;
            }
    </style>
    </head>
    <body>
    <div class="father">
        <div class="nav">导航A</div>
        <div class="nav">导航B</div>
        <div class="nav">导航C</div>
        <div class="nav">导航D</div>
    </div>
    
    </body>
    </html>
    ```

### 1.9CSS定位应用

```html
<!--使用定位属性固定侧边栏及布局-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        /*消除所有的外边距和内边距*/
        *{
            margin:0;
            padding: 0;
        }
        /*设置根元素和主体的宽高*/
        html,body{
            /*宽高设为视窗宽高的百分百*/
            height: 100%;
            width: 100%;
            /*设置盒子box-sizing为border-box，即指定元素的宽高包括边框内边距和内容的宽高*/
            box-sizing: border-box;
        }
        .content{
            /*设置背景图，图像仅显示一次，背景图片从窗口的中上部开始加载*/
            background: url("mooc.png") no-repeat top center;
            /*宽度设为body的宽度，高度设为背景图片的高度*/
            width: 100%;
            height: 4043px;
        }
        .login{
            /*设置为固定定位*/
            position: fixed;
           	/*设置背景图，图像仅显示一次*/
            background: url("login.png") no-repeat;
            /*固定定位脱离html文档流，块级元素不设置宽度也不会默认占据一行，所以必须设置宽高*/
            width: 360px;
            height: 363px;
            /*距离上方50%，左边50%，并设置上左外边距，使之居中固定*/
            top: 50%;
            left: 50%;
         /*当元素已设置宽度的情况下，左右外边距为负值会进行相应的偏移，未设置宽度的情况下，左右外边距为负值会相应增加元素的宽*/
         /*无论是否有设置高度，上外边距为负值时，都会进行相应的偏移*/
         /*下外边距为负值的时候不会位移,而是会减少自身供css读取的高度*/
            margin-left: -180px;
            margin-top: -180px;
        }
        .nav{
            /*设置固定定位，用于固定侧边栏*/
            position: fixed;
            /*距上方50%，并设置上外边距，使之居中固定*/
            top:50%;
            margin-top: -102px;
            width: 160px;
            /*设置高度为自动，由子元素撑起来*/
            height: auto;
        
        }
        .bar{
            /*设置宽度为nav的宽度*/
            width: 100%;
            /*设置高度为自动，由子元素撑起来*/
            height: auto;
            background-color:#333333;
            border-bottom: solid 1px white;
            color:white;
            font-size: 16px;
            /*设置文本左右居中*/
            text-align: center;
            /*设置上下居中*/
            line-height: 40px;
            /*设置当光标在该元素区域内为可点击的形状*/
            cursor: pointer;
        }
        .bar ul{
            /*设置宽度为bar的宽度*/
            width: 100%;
            /*设置高度为自动，由子元素撑起来*/
            height: auto;
            /*默认初始时ul元素不显示*/
            display: none;
        }
        .bar ul li{
            /*设置相对定位，用于给绝对定位的sonnav作参照物进行偏移*/
            position: relative;
            /*设置宽度为ul的宽度*/
            width: 100%;
            height: 40px;
            border-bottom: dashed 1px #666666;
            color:#333333;
            background-color: #FFFF;
        }
        /*.bar:hover ul表示当鼠标悬浮在类名为bar元素上时，设置ul的样式*/
        .bar:hover ul{
            /*当鼠标悬浮在类名为bar元素上时，显示ul元素*/
            /*实现了弹出框的效果*/
            display: block;
        }
        .sonnav{
            /*设置绝对定位，相对li元素进行偏移*/
            position: absolute;
            /*设置宽度为li的宽度*/
            width: 100%;
            /*设置高度为自动，由子元素撑起来*/
            height: auto;
            /*距li元素160像素*/
            left: 160px;
            /*距li元素上部0像素*/
            top:0;
            /*初始不显示*/
            display: none;
        }
        .sonbar{
            /*设置宽度为sonnav的宽度*/
            width:100%;
            height: 40px;
            background-color: #444;
            color:#FFFF;
            border-bottom: solid 1px #FFFF;
        }
        ul li:hover .sonnav{
           	/*当鼠标悬浮在类名为li元素上时，显示类名为sonnav的元素*/
            display: block;
        }

    </style>
</head>
<body>
    <div class="content"></div>
    <div class="login"></div>
    <!--侧边栏-->
    <div class="nav">
        <div class="bar">慕课网的标题
            <!--弹出框-->
            <ul>
                <li>二级栏目
                    <!--子侧边栏-->
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
            </ul>
        </div>
        <div class="bar">慕课网的标题
            <ul>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
            </ul>
        </div>
        <div class="bar">慕课网的标题
            <ul>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
            </ul>
        </div>
        <div class="bar">慕课网的标题
            <ul>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
            </ul>
        </div>
        <div class="bar">慕课网的标题
            <ul>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
                <li>二级栏目
                    <div class="sonnav">
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                        <div class="sonbar">三级栏目</div>
                    </div>
                </li>
            </ul>
        </div>
    </div>
</body>
</html>
```

## 2.HTML

HTML = Hypertext Markup Language(**超文本标记语言**)

### 2.1HTML标签

- **基本文档**

  ```html
  <!--定义文档类型-->
  <!DOCTYPE html>
  <!--html标签是根标签-->
  <html>
  <!--head标签定义html页面的头部分-->
  <head>
  <!--title标签定义页面标题-->
  <title>文档标题</title>
  </head>
  <!--body标签定义页面主体-->
  <body> 可见文本... </body>
  </html>
  ```

- **基本标签**

  ```html
  <h1>最大的标题</h1>
   <h2> . . . </h2>
   <h3> . . . </h3>
   <h4> . . . </h4>
   <h5> . . . </h5>
   <h6>最小的标题</h6>
  
   <p>这是一个段落。</p>
  
   <br>（换行）
   <hr> （水平线）
   <!-- 这是注释 -->
  ```

- **文本格式化标签**

  ```HTML
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
  </head>
  <body>
  <b>粗体文本</b>
  <strong>重要的文本</strong>
  <em>强调文本</em>
  <i>斜体文本</i>
  <small>更小的文本</small>
  <sub> （下标文本）</sub>
  <sup> （上标文本）</sup>
  </body>
  </html>
  ```

- **链接标签**

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
  </head>
  <body>
  <!--a标签的target属性为_blank表示从新窗口打开网址-->
  <a href="www.baidu.com" target="_blank">从新窗口打开百度</a>
  <!--a标签的target属性为_self表示从本窗口打开网址，不产生新窗口-->
  <a href="www.baidu.com" target="_self">本窗口直接跳转至百度</a>
  <!--当href属性为#id名，则表示跳转至本页面id名为xxx的标签-->
  <a href="#ddd">跳转到页面内的锚点</a>
  <p id="ddd">ddsdsa</p>
  <!--当href属性设置为javascript:;或javascript:void(0);则表示禁止跳转-->
  <a href="javascript:;">禁止跳转</a>
  <a href="javascript:void(0);">禁止跳转</a>    
  </body>
  </html>
  ```

- **图像标签**

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
  </head>
  <body>
  <!--alt属性用于当图片无法正常显示时，则会显示alt属性的值，src属性表示要插入图像的路径-->
  <img src="URL.png" alt="替换文本" height="42" width="42">
  </body>
  </html>
  ```

- **div标签**

  无特殊语义，用于布局分块

- **列表标签**

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
  </head>
  <body>
  <!-- 无序列表 -->
  <!--生成的列表无下标-->
  <ul>
    <li>项目</li>
    <li>项目</li>
  </ul>
  
  <!-- 有序列表 -->
  <!--生成的列表有下标-->
  <ol>
    <li>第一项</li>
    <li>第二项</li>
  </ol>
  
  <!-- 定义列表 -->
  <!--dt表示定义的事物的名字，dd表示对定义事物的解释,dd会对文本缩进-->
  <dl>
    <dt>项目 1</dt>
    <dd>描述项目 1</dd>
    <dt>项目 2</dt>
    <dd>描述项目 2</dd>
  </dl>
  </body>
  </html>
  ```

- **表格标签**

  table标签涵盖的属性

  ![image-20201016161738939](/static/img/image-20201016161738939.png)

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
  </head>
  <body>
  <!--table标签由th，tr，td，tbody，tfoot子标签，其中td和tr是必须的-->
  <table border="1">
    <!--tr标签表示表格的一行-->
    <tr>
  	<!--th标签表示表格头-->
      <th>表格标题</th>
      <th>表格标题</th>
    </tr>
    <!--tbody表示表格的主体-->
    <tbody>
    <tr>
      <!--td标签表示表格的每一个单元格-->
      <td>表格数据</td>
      <td>表格数据</td>
    </tr>
    </tbody>
    <!--tfoot表示表格的尾部-->
    <tfoot>
    <tr>
      <td>表格尾</td>
      <td>表格尾</td>
    </tr>
    </tfoot>
  </table>
  </body>
  </html>
  ```

- **表单标签**

  ![image-20201016162114484](/static/img/image-20201016162114484.png)
  
  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>CSS布局</title>
  </head>
  <body>
  <!--form标签的action属性表示，需要提交到的服务器地址-->
  <form action="" id="test" >
    <!--input标签的type类型用于指定输入框的类型-->
    <!--文本输入框，maxlength属性用于指定文本最大输入长度，value属性指定文本框初始默认值--> 
    <input type="text" maxlength="10" value="请输入...">
    <!--密码输入框，输入的文字会加密不可视-->  
    <input type="password">
    <!--单选按钮，多个单选按钮name属性需要设置为相同的值，才能实现单选功能-->  
    <input type="radio" name="gender" >男<input type="radio" name="gender" >女
    <!--多选按钮，checked属性表示初始选择该按钮-->   
    <input checked type="checkbox">1
    <input type="checkbox">2
    <input type="checkbox">3
    <!--按钮类型-->
    <input type="button"value="按钮">
    <!--数字输入框-->
    <input type="number">
    <!--选择日期输入框-->    
    <input type="date">
    <!--选择颜色输入框-->    
    <input type="color">
    <!--选择范围输入框-->    
    <input type="range">
    <!--邮件输入框-->    
    <input type="email">
    <!--提交表单按钮-->    
    <input type="submit" value="提交">
    <!--网址输入框-->    
    <input type="url">
    <!--选择文件输入框，multiple属性表示可选择多个文件-->    
    <input type="file" multiple>
    <!--select标签表示下拉框，子标签option用于表示选项-->    
    <select>
      <option>1</option>
      <!--selected属性表示初始默认选择该选项-->    
      <option selected>2</option>
    </select>
    <!--textarea文本域输入框，用于输入多行文本，rows和cols用于设置文本域行和列的大小-->    
    <textarea rows="3" cols="4">
    <!--此处设置初始文本域显示的文字-->      
      ddd
    </textarea>
    <!--button标签用三个类型，reset用于将表单中所有元素重置为默认值，submit用于将表单数据提交到指定服务器，button普通的按钮-->
    <!--form属性表示button需要应用的表单，属性值为form标签的id属性-->
    <button type="reset" form="test">重置</button>
  </form>
  </body>
  </html>
  ```

### 2.2块级元素和行内元素

- **块级元素**：div，form，table标签等

  1.总是从新的一行开始

  2.高度、宽度都是可控的

  3.宽度没有设置时，默认为100%

  4.块级元素中可以包含块级元素和行内元素

- **行内元素**：a，span，img标签等

  1.和其他元素在一行中，当他们宽度超过了容器的宽度才会自动换行；
  2.高度、宽度以及内外边距的top/bottom都是不可控的，只有内外边距的left/right是可控
  3.宽高就是内容的高度，不可以改变
  4.行内元素只能包含行内元素，不能包含块级元素

## 3.JavaScript

### 3.1初始JavaScript

浏览器解析HTML，发现script标签时，会先下载完所有这些script，才会再往下解析其他的HTML

#### 3.1.1JS输出

- `window.alert()`：写入警告框

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <script type="text/javascript">
      window.alert("警告");//alert方法接收一个值，用于警告框中的文本内容
  </script>
  </body>
  </html>
  ```

- `document.write()`：写入HTML文档中（在 HTML 文档完全加载后使用 `document.write()`将*删除所有已有的 HTML* ）

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <script type="text/javascript">
      document.write("helloworld");//write方法接收一个值，用于写入到html文档中
  </script>
  </body>
  </html>
  ```

- `innerHTML`：写入到HTML元素

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <p id="pp"></p>
  <script type="text/javascript">
      //innerHTML属性接收一个值，用于写入html元素中
      document.getElementById('pp').innerHTML='nihao';//获得html文档中id名为pp的标签，然后将innerHTML属性值写入该标签
  </script>
  </body>
  </html>
  ```

- `console.log()`：输出到浏览器的控制台

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <script type="text/javascript">
      console.log(123)
  </script>
  </body>
  </html>
  ```

#### 3.1.2JS数据类型

- 数字

  ```javascript
  var a=7;
  ```

- 字符串

  ```javascript
  var a='7'
  ```

- 布尔

  ```javascript
  var a1=true
  var a2=false
  ```

- 数组

  ```javascript
  var a1=['1',2,3]
  var a2=new Array([1,2,3])
  ```

- 对象（键值对的方式）

  ```javascript
  var a={
  	name:'zwf',
  	age:18
  }
  ```

- 空

  ```javascript
  var a=null;
  ```

- 未定义

  ```javascript
  var a;
  ```

#### 3.1.3JS变量

- 变量必须以字母开头
- 变量也能以$和_符号开头
- 变量名称对大小写敏感（Y和y不是一个变量）

#### 3.1.4JS函数

JS函数使用关键字function定义，无论函数在JS代码的何处定义，都会自动前置声明

语法：`function a(参数){}`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    a();//即使函数a在调用语句的后面定义，也不会报错，因为函数a的声明会自动前置
    function a(){
        console.log(1,2,3);
    }
</script>
</body>
</html>
```

匿名函数语法：`var a=function(参数){}`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    //将匿名函数赋给变量a
    var a=function (){
        return [1,2,3];
    }
    //此时调用a()即调用匿名函数,控制台输出return的返回值
    console.log(a());
</script>
</body>
</html>
```

#### 3.1.5JS比较运算符

- `==`：等于（等值不等型也为true）
- `===`：等值等型（等值等型才为true）
- `!=`：不想等
- `!==`：不等值或不等型

### 3.2JavaScript中的DOM操作

#### 3.2.1DOM简介

![img](/static/img/1855281-20200427200638297-734611544.png)

常用的DOM操作

![img](/static/img/1855281-20200427200646684-1490112770.png)

#### 3.2.2DOM-HTML

修改HTML元素属性：

- `element.getAttribute()`：获取元素的属性值

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <p date="aaa" id="pp"></p>
  <script type="text/javascript">
      var p=document.getElementById("pp");//获取p元素
      var a=p.getAttribute("date");//获取p元素的date属性值
  </script>
  </body>
  </html>
  ```

- `element.setAttribute()`：设置或修改元素的属性值

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <p date="aaa" id="pp"></p>
  <script type="text/javascript">
      var p=document.getElementById("pp");//获取p元素
      p.setAttribute("date","bbb");//setAttribute接收两个参数，第一个参数是元素的属性名，第二个参数是需要设置的值
  </script>
  </body>
  </html>
  ```

- `element.src`：设置或修改元素的src属性

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <a href="" id="aa">链接</a>
  <script type="text/javascript">
      var a=document.getElementById("aa");//获取a元素
      a.href="www.baidu.com";//设置a标签的href属性
  </script>
  </body>
  </html>
  ```

- `element.href`：设置或修改元素的href属性

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <img id="ii" src="" alt="">
  <script type="text/javascript">
      var img=document.getElementById("ii");//获取img元素
      img.src="ddd";//设置img标签的src属性
  </script>
  </body>
  </html>
  ```

### 3.3DOM-CSS

修改CSS样式：

语法：`element.style.要修改的属性=修改值`

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        p{
            color: black;
        }
    </style>
</head>
<body>
<p id="pp">helloworld</p>
<script type="text/javascript">
    var p=document.getElementById("pp");//获取p元素
    p.style.color="blue"//修改p标签的color属性值为蓝色
</script>
</body>
</html>
```

### 3.4DOM-事件

事件：元素+动作+反应的结果

![img](/static/img/1855281-20200427200625491-1250503351.png)

DOM-事件的三种方式：

- 事件内嵌元素中：

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <form>
      <!--元素input，动作onclick，反应的结果alert('helloworld')-->
      <!--点击input元素会促发警告框-->
      <input type="button" onclick="alert('helloworld')" value="按钮">
  </form>
  </body>
  </html>
  ```

- 使用JS代码`Element.触发事件的属性=function(){反应的结果}`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <form>
      <input id="btn" type="button" value="按钮">
  </form>
  <script>
      var btn=document.getElementById("btn");//获取input元素
      //设置input标签的onclick属性，当input元素被点击，会触发onclick属性，然后调用这个匿名方法
      btn.onclick=function (){
          alert("警告");
      }
  </script>
  </body>
  </html>
  ```

- 使用JS代码`Element.addEventListener(动作,function(){反应的结果})`

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <form>
      <input id="btn" type="button" value="按钮">
  </form>
  <script>
      var btn=document.getElementById("btn");//获取input元素
      //addEventListener方法第一个参数表示动作类型，第二个参数表示事件触发后的反馈
      btn.addEventListener("click",function (){
          alert("helloworld");//当input标签被点击，该匿名函数就会被调用
      });
  </script>
  </body>
  </html>
  ```

### 3.5DOM-节点

- 整个文档是一个文档节点
- 每个 HTML 元素是元素节点
- HTML 元素内的文本是文本节点
- 每个 HTML 属性是属性节点
- 注释是注释节点

![HTML DOM Node Tree](/static/img/ct_htmltree.gif)

使用JS代码修改文档中的节点：

- `document.createElement(节点名)`：为html文档创建一个元素节点

- `document.createTextNode(文本内容)`：为html文档创建一个文本节点

- `Element.appendChild(节点名)`：为元素添加一个子节点

- `Element.removeChild(节点名)`：为元素移除一个子节点

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <script>
      var p=document.createElement("p");//为HTML文档创建一个p元素节点，相当于<p></p>
      var text=document.createTextNode("helloworld");//为HTML文档创建一个文本节点,相当于helloworld
      var body=document.getElementsByTagName("body")[0];//获取body标签
      p.appendChild(text);//将文本节点添加为p元素节点的子节点，相当于<p>helloworld</p>
      body.appendChild(p);//将p元素节点添加为body元素的子节点
      body.remove(p);//将body元素下的p元素节点移除
  </script>
  </body>
  </html>
  ```

### 3.6JavaScript中的window对象

#### 3.6.1JS-window

- **window的概念**w

  - 所有浏览器都支持window对象，window对象表示浏览器窗口

  - 所有JavaScript的全局对象，函数，变量均自动成为window对象的成员

  - 全局变量就是window对象的属性

  - 全局函数就是window对象的方法

    ```html
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Title</title>
    </head>
    <body>
    <script>
        var a="hello";
        function b(){
        }
        window.a;//window.a即a变量
        window.b()//window.b()即函数b
    </script>
    </body>
    </html>
    ```

- **window的方法**

  ```html
  <!DOCTYPE html>
  <html lang="en">
  <head>
      <meta charset="UTF-8">
      <title>Title</title>
  </head>
  <body>
  <button onclick="openWindow()">打开窗口</button>
  <button onclick="resizeWindow()">调整窗口</button>
  <button onclick="moveWindow()">移动窗口</button>
  <button onclick="closeWindow()">关闭窗口</button>
  <script>
      var w;
      function openWindow(){
          //window.open方法用于打开一个新窗口
          //第一个参数接收一个字符串，是新建的窗口需要跳转到的url，第二个参数接收一个字符串，是窗口的名字，第三个参数接收一个字符串，表示窗口的宽和高
          w=window.open("","","height=300,width=300");
      }
      function resizeWindow(){
          //窗口对象的resizeTo方法用于调整窗口大小，第一个参数为调整后的宽度，第二个参数为调整后的高度
          w.resizeTo(500,500);
          //窗口对象的focus方法用于聚焦该窗口
          w.focus();
      }
      function moveWindow(){
          //窗口对象的moveTo方法用于调整窗口在屏幕上的位置，第一个参数为窗口在屏幕的横向位置，第二个参数为窗口在屏幕的纵向位置
          w.moveTo(700,500);
          w.focus();
      }
      function closeWindow(){
          w.close();//窗口对象的close方法用于关闭该窗口
          w.focus();
      }
  </script>
  </body>
  </html>
  ```

#### 3.6.2window-screen

`window.screen` 对象包含有关用户屏幕的信息

- `window.screen`对象在编写时可以不写window前缀
- `screen.availWidth`：获取屏幕可用宽度
- `screen.availHeight`：获取屏幕可用高度

#### 3.6.3window-location

以https://coding.imooc.com/class/package/435.html#Anchor为例

- `location.hostname`：返回当前页面的域名（返回coding.imooc.com）
- `location.pathname`：返回当前页面的文件路径名（返回/class/package/435.html）
- `location.protocol`：返回当前页面的web协议（http:或https:）
- `location.href`：可以设置或返回当前页面的整个url（https://coding.imooc.com/class/package/435.html#Anchor）

#### 3.6.4window-history

`window.history` 对象包含浏览器的历史

- `history.back()` ：与在浏览器点击后退按钮相同
- `history.forward()` ：与在浏览器中点击向前按钮相同
- `history.go(var number)`：实现向前或向后多页的功能，以当前页面为基准，传入的number为0，即刷新当前页面，传入的number为正数n，则向前n页，为负数n，则向后n页

### 3.7JavaScript实现轮播特效

`setInterval(handler: TimerHandler, timeout?: number, ...arguments: any[])`：用于设置定时器，参数handler接收一个函数，用于定时器执行，参数timeout接收一个数字，表示周期性调用handler的时间间隔（单位是毫秒）

`clearInterval(handle?: number)`：用于清除设置的定时器，参数handler接收要清除的定时器

轮播特效的实现：通过js设置定时器，周期性的让不同的图片显示消失来实现轮播特效

```javascript
//demo.js
var slides=ById("bottom").getElementsByTagName("div");//获取id为bottom标签下的所有div标签，即获取包裹图片的标签
var index=0;//图片索引
var timer=null;//定时器
var len=slides.length;
//封装document.getElementById函数，以简化代码量
function ById(Id){
    //当传来的参数为string类型，则返回对应的标签
    if(typeof (Id)==="string"){
        return document.getElementById(Id);
    }
    else{
        //否则原样返回
        return Id;
    }
}
//自动轮播
function autoPlay(){
    //设置定时器
    timer=setInterval(function (){//定时器要执行的目标函数
        index++;//图片索引+1
        //当图片索引超过图片数量时，图片索引变为第一张
        if(index>=len){
            index=0;
        }
        //切换图片
        changeImg();
    },3000);//设置每3s执行一次目标函数
}
//停止轮播
function stopPlay(){
    //清除定时器
    if(timer) {
        clearInterval(timer);
    }
}
//切换图片
function changeImg(){
    //将所有图片都隐藏
    for(var i=0;i<len;i++){
        slides[i].style.display="none";
    }
    //将当前轮播的图片显示
    slides[index].style.display="block";
}

function slideImg(){
    var main=ById("main");//获取main标签，即包含整个轮播图的标签
    //onmouseover事件，当鼠标滑过该标签时，调用该匿名函数
  	//此处设置为停止轮播
    main.onmouseover=function (){
       stopPlay();
    }
    //onmouseout事件，当鼠标滑开该标签时，调用该匿名函数
    //此处设置为自动轮播
    main.onmouseout=function(){
        autoPlay();
    }
    //onmouseout函数，表示模拟鼠标滑开该标签
    //页面初显示时并不会自动轮播，因为鼠标并未滑开该标签，无法触发事件，所以要设置onmouseout函数，模拟鼠标滑开该标签
    main.onmouseout();
}
slideImg();//调用函数
```

```html
<!--demo.html-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link type="text/css" rel="stylesheet" href="demo.css">
</head>
<body>
<div class="main" id="main">
   <div class="bottom" id="bottom">
       <!--第一张图-->
        <div class="slide slide1">
            <a href="#">
                <img src="img/bg1.jpg" alt="">
            </a>
        </div>
        <!--第二张图-->
        <div class="slide slide2">
            <a href="#">
                <img src="img/bg2.jpg" alt="">
            </a>
        </div>
        <!--第三张图-->
        <div class="slide slide3">
            <a href="#">
                <img src="img/bg3.jpg" alt="">
            </a>
        </div>
    </div>
</div>
<script src="demo.js"></script>
</body>
</html>
```

```css
*{
    margin: 0;
    padding:0;
    text-decoration: none;
    list-style: none;
}
html,body{
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    font-family: "微软雅黑", serif;
}
.main{
    width: 1200px;
    height: 460px;
    margin:30px auto;
    position: relative;
}
.bottom{
    width: 100%;
    height: 100%;
    top:0;
    position: absolute;
}
.slide{
    width: 100%;
    height: 100%;
    /*隐藏所有图片*/
    display: none;
}
.slide1{
    /*初始显示第一张图*/
    display: block;
}
```

## 4.JSP

### 4.1JSP简介

**JSP**：全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码

**JSP程序示例**：

```jsp
<!--此处为JSP语法，<%@page%>为page指令，用于告诉tomcat服务器如何翻译jsp文件-->
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>Title</title>
  </head>
  <body>
  <h1>hello web</h1>
  </body>
</html>
```

### 4.2动态web项目结构

![image-20201030195154320](/static/img/image-20201030195154320.png)

- **src目录**：存放java源码
- **web目录**：存放web工程的资源文件，如html，css，javascript等
- **WEB-INF目录**：是一个受到服务器保护的目录，浏览器无法直接访问到
- **classes目录**：java编译器产生的类文件输出目录，应用程序载入器使用此目录中的类来装载运行时所需要的功能
- **lib目录**：包含了web应用程序所引用的支持性jar文件，是综合的资源文件目录
- **web.xml**：是整个动态web工程部署描述文件。可以在这些配置很多web工程的组件

### 4.3JSP程序的执行流程

1. 用户向Web服务器请求某个JSP页面
2. Web服务器接收到用户请求，加载相应的JSP文件，Web服务器中的JSP引擎会将被加载的JSP文件转化为Servlet
3. JSP引擎将生成的Servlet代码编译成Class文件
4. Web服务器执行这个Class文件
5. 服务器将执行结果发送给浏览器进行显示

### 4.4JSP的基本语法

- **JSP声明语法**：

  JSP引擎转换JSP页面成Java文件时，声明语法中定义的变量和方法会成为整个页面的成员变量和成员方法

  语法：`<%!变量或方法的声明%>`

  ```jsp
  <!--仅用于定义变量或方法，不能包含输出等程序语句-->
  <%!String str="hello world";%>
  ```

- **JSP程序脚本**
  - 包括变量的声明、表达式和程序逻辑
  - JSP程序脚本中声明的变量为局部变量
  - 语句块可以自由的与页面代码组合使用

  语法：`<%程序脚本%>`

  ```jsp
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
    <head>
      <title>Title</title>
    </head>
    <body>
    <!--jsp程序脚本的语句块可以和html标签交叉使用-->
    <%
      int i=11;
      if(i>10){
    %>
    <span>i>10</span>
    <%}
    else{
    %>
    <span>i<=10</span>
    <%}%>
    <!--此处a为成员变量，生命周期是从变量创建到服务器关闭-->    
    <%!int a=0;%>
    <!--此处b为局部变量，当页面刷新后，局部变量就被回收了-->
    <%int b=0;%>
    <%
    //不停刷新jsp页面，只用a变量会不断加一，b变量每次刷新后都会被重置为0
      a++;
      b++;
      out.println(a);//往页面中输出a
      out.println(b);//往页面中输出b
    %>
    </body>
  </html>
  ```

- **JSP注释**

  在JSP程序中，可以使用html注释来注释html代码，java注释来注释java代码，也可以用JSP注释来注释html代码、java代码和jsp代码

  JSP注释语法：`<%--Java脚本、JSP中其他代码--%>`

- **JSP内容输出表达式**

  JSP内容输出表达式可以将变量的值或方法的返回值输出到页面中，作用同`<%out.println(输出的内容)%>`一样

  语法：`<%=输出的内容%>`（输出的变量名称或方法不需要添加分号）

  ```jsp
  <!--将变量i的值输出到jsp页面中-->
  <%=i%>
  ```

- **JSP包引入**

  - **引入单个包**

    语法：`<%@page import="包名"%>`

  - **引入多个包**

    语法：`<%@page import="包名1,包名2"%>`

### 4.5JSP内置对象

- **request对象**：封装了由WEB浏览器或其它客户端生成地HTTP请求的细节（参数，属性，头标和数据）。作用域为request(用户请求期）

  ```jsp
  <!--index.jsp-->
  <!--当访问index页面时，会生成一个请求对象，并保存name属性，然后将请求转发给control.jsp页面，此时index页面显示的是control页面的内容-->
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>人事管理系统</title>
  </head>
  <body>
  <%
      //将name属性设值并保存到request对象中
      request.setAttribute("name","ddd");
      //将请求转发给control.jsp页面
      request.getRequestDispatcher("control.jsp").forward(request,response);
  %>
  </body>
  </html>
  ```

  ```jsp
  <!--control.jsp-->
  <!--control.jsp和index.jsp共享同一个request对象-->
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
  <!--获取request对象的name属性值-->    
  <%=request.getAttribute("name")%>
  </body>
  </html>
  ```

  ```jsp
  <!--获得访问该页面的请求对象的参数-->
  <%request.getParameter("参数名")%>
  ```

- **response对象**：封装了返回到HTTP客户端的输出，向页面作者提供设置响应头标和状态码的方式。经常用来设置HTTP标题，添加cookie，设置响应内容的类型和状态，发送HTTP重定向和编码URL。作用域为page（页面执行期）

  ```jsp
  <!--获得当前页面的编码-->
  <%=response.getCharacterEncoding()%>
  ```

- **out对象**：代表输出流的对象。作用域为page（页面执行期）

  ```jsp
  <!--向当前页面输出内容-->
  <%out.printlin("输出的内容")%>
  ```

- **pageContext对象**：作用域为page（页面执行期）。此对象提供所有四个作用域层次的属性查询和修改能力，它也提供了转发请求到其它资源和包含其他资源的方法

  ```jsp
  <%
  	//pageContext对象的forward方法能实现转发请求的功能
      pageContext.forward("转发到的页面");
  	//pageContext对象的include方法用于向当前页面包含其他文件，比如可以为html头部、尾部或导航栏专门编写一个文件，然后在将这些文件include进来
  	pageContext.include("需要包含的文件名");
  	//pageContext对象还可以获取其他内置对象
      pageContext.getRequest();
      pageContext.getSession();
  	...
  %>
  ```

- **session对象**：主要用于跟踪会话，作用域session，即用户从访问网站的每个页面到离开网站的这段时间，session对象的信息都能被网站所有页面共享

  ```jsp
  <%
  //将设置account属性并保存在session对象，在用户离开网站前，account属性被所有网页共享
  session.setAttribute("account","aaa");
  //session的setMaxInactiveInterval方法用于设置会话的超时值，即会话超时后，session对象中保存的共享信息也就被清除
  session.setMaxInactiveInterval(1);//单位毫秒
  %>
  ```

- **application对象**：负责提供应用程序在服务器中运行时的一些全局信息，作用域为web容器的生命周期

  ```jsp
  <%
  //在服务器关闭前，count属性值都是可以被共享修改的
  application.setAttribute("count",1);
  %>
  ```

- **page对象**：表示正在运行的由JSP文件产生的类对象，作用域为page（页面执行期）

  ```jsp
  <!--jsp文件中的this即表示当前页面对象page对象，getServletInfo()用于获得当前页面基本信息-->
  <%=this.getServletInfo()%>
  ```

- **config对象**：获取配置信息，作用域为page（页面执行期）

  ```jsp
  <%
  //获得web.xml中配置的servlet名
  config.getServletName();
  //获得web.xml中配置的初始化参数
  config.getInitParameter("参数名");
  %>
  ```

- **exception对象**：JSP文件运行时所产生的例外对象，此对象不能在一般JSP文件中直接使用，而只能在使用了`<%@ page isErrorPage="true "%>`的JSP文件中使用

  ```jsp
  <!--error.jsp-->
  <!--用于处理错误的页面必须设置isErrorPage="true"-->
  <%@ page contentType="text/html;charset=UTF-8" language="java" isErrorPage="true" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
      <!--当其他页面抛出错误，并且设置errorPage="error.jsp",则error.jsp页面会处理这些错误-->
      <!--exception.getMessage()方法用于获取抛出错误的信息-->
      <%=exception.getMessage()%>
  </body>
  </html>
  ```

## 5.XML

### 5.1XML简介

**概述**：

- XML 指可扩展标记语言（*EX*tensible *M*arkup *L*anguage）
- XML 是一种*标记语言*，很类似 HTML
- XML 的设计宗旨是*传输数据*，而非显示数据
- XML 标签没有被预定义。需要用户*自行定义标签*。

**应用**：

- 用于将数据从HTML中分离出来
- 简化数据的共享
- 简化数据的传输
- 简化平台的变更

### 5.2XML文档规则

- **XML整体结构**

  1. 有且只有一个根元素
  2. 元素必须合理结束
  3. 元素之间必须合理嵌套
  4. 元素的属性必须有值

- **XML声明**
  `<?xml version="1.0" encoding="UTF8" standalone="yes"?>`

  1. `version`属性：用于说明当前xml文档的版本，因为都是在用1.0，所以这个属性值大家都写1.0，version属性是必须的；
  2. `encoding`属性：用于说明当前xml文档使用的字符编码集，xml解析器会使用这个编码来解析xml文档。encoding属性是可选的，默认为UTF-8。注意，如果当前xml文档使用的字符编码集是gb2312，而encoding属性的值为UTF-8，那么一定会出错的；
  3.  `standalone`属性：用于说明当前xml文档是否为独立文档，如果该属性值为yes，表示当前xml文档是独立的，如果为no表示当前xml文档不是独立的，即依赖外部的约束文件。默认是yes

- **XML元素的基本规则**

  1. 合法标签名

     - XML元素由开始标签和结束标签组成，结束标签比开始标签多一条斜线\
     - XML文档区分大小写，因此开始标签和结束标签的名称要一致
     - 标签名可以含字母、数字以及其他的字符，但不能以数字或者标点符号开始，不能以字符 “xml”（或者 XML、Xml）开始，标签名中不能包含空格

     ```xml
     <!--这就是一个合法标签名-->
     <name></name>
     ```

  2. 嵌套子元素

     - XML允许无限深度嵌套子元素，只要保证元素之间合理嵌套即可
     - XML元素可以嵌套多个重名的子元素，这多个元素之间是有序的

     ```xml
     <!--标签书籍列表下嵌套了多个子元素-->
     <书籍列表>
         <!--标签书籍列表可以嵌套多个计算机书籍标签，他们是并列的-->
         <计算机书籍>
             <书名>Spring</书名>
             <价格>100.00</价格>
         </计算机书籍>
         <计算机书籍>
             <书名>JAVA</书名>
             <价格>80.00</价格>
         </计算机书籍>
     </书籍列表>
     ```

  3. 空元素

     - XML允许使用空元素语法，空元素不可接受子元素，也不可接受字符串内容
     - 空元素和内容为空的元素并不相同
     - 空元素只是不能包含子元素，也不能包含字符串内容，但是可以接受属性

     ```xml
     <!--空元素可以接受属性-->
     <名著 price="100.00"/>
     <!--内容为空的元素-->
     <name></name>
     ```

- **字符数据**

  开始标签和结束标签之间的文本即字符数据

  1. 使用实体引用处理XML中的特殊字符

     ![image-20201102203957427](/static/img/image-20201102203957427.png)

  2. 使用CDATA标记

     语法：`<![CDATA[标记的内容]]>`

     作用： 在特殊标记CDATA下，不管是特殊字符还是有效的xml元素都会失效，变成纯文本

     ```xml
     <!--CDATA标记下，<书名>JAVA</书名>元素变为了纯文本-->
     <价格><![CDATA[ <书名>JAVA</书名>]]></价格>
     ```

- **注释**

  语法：`<!--注释内容-->`

  1. 不要把注释放在标签之内
  2. 不要把注释放在XML声明之前，XML声明应该永远在第一行
  3. 不要在注释中使用双中划线（--）

- **有效的XML文档**

  遵守了XML文档规则，并使用DTD或Schema定义了语义约束，而且也完全遵守了DTD或Schema所定义的语义约束的XML文档

  **DTD语法**：

  - 互联网导入：`<!DOCTYPE 根元素 PUBLIC "dtd文件的地址">`

  - 标签约束：`<!ELEMENT 元素名称 类别>  或 <!ELEMENT 元素名称 (元素内容)>`

  - 类别：

    - 空标签：EMPTY， 表示元素一定是空标签
    - 普通字符串 ：(#PCDATA)，表示标签的内容一定是普通字符串（不能含有子标签）
    - 任何内容： ANY，表示元素的内容可以是任意内容（包括子标签）

  - 顺序：按顺序出现子标签

    `<!ELEMENT 元素名称 (子元素名称 1,子元素名称 2,.....)>` 

  - 次数：

    - 标签 ： 必须且只出现1次。
    - 标签+ ： 至少出现1次
    - 标签* ： 0或n次。
    - 标签？ ： 0 或1次。

  ```xml
  <?xml version="1.0" encoding="UTF8" standalone="yes"?>
  <!--DTD约束-->
  <!DOCTYPE 书籍列表[
          <!ELEMENT 书籍列表 ((计算机书籍+))>
          <!ELEMENT 计算机书籍 ((书名,价格))>
          <!ELEMENT 书名 (#PCDATA)>
          <!ELEMENT 价格 (#PCDATA)>
          ]>
  <书籍列表>
      <计算机书籍>
          <书名>Spring</书名>
          <价格>100.00</价格>
      </计算机书籍>
      <计算机书籍>
          <书名>JAVA</书名>
          <价格>80.00</价格>
      </计算机书籍>
  </书籍列表>
  ```

### 5.3XML命名空间

使用命名空间区分同一个文档中同名的元素和属性

语法：`xmlns:prefix="命名空间字符串"`（prefix表示命名空间的名字，命名空间字符串往往是一个绝对的URL地址）

```xml
<?xml version="1.0" encoding="UTF8" standalone="yes"?>
<书籍列表>
    <计算机书籍 xmlns:book="http://www.muke.com">
        <!--这个name属于book命名空间-->
        <book:name>Spring</book:name>
        <作者 xmlns:author="http://www.xinhua.com">
            <!--这个name属于author命名空间-->
            <author:name>zwf</author:name>
        </作者>
        <价格>100.00</价格>
    </计算机书籍> 
</书籍列表>
```

### 5.4使用SAX读写XML文档

- **XML文档的解析方式**

  1. DOM：文档对象模型，Dom解析是将XML文件全部载入到内存，组装成一颗dom树，然后通过节点以及节点之间的关系来解析XML文件，与平台无关
  2. SAX：Simple API for XML，基于事件驱动,逐条解析,适用于只处理xml数据，不易编码,而且很难同时访问同一个文档中的多处不同数据

- **XML文档解析原理**

  XML文档---->XML解析器---->解析结果

- **JAXP（Java API for XML Processing）**

  Java解析xml文档的API，允许应用程序在不同XML解析器之间切换

  - JAXP提供的与解析相关的类
    - `DocumentBuilderFactory`：获取DOM解析工厂类
    - `DocumentBuilder`：DOM解析器标准接口
    - `SAXParserFactory`：获取SAX解析工厂类
    - `SAXParser`：SAX解析器标准接口

- **SAX解析XML文档流程**

  SAX解析器在XML文档中行走，每当遇到文档开始，元素开始，文本，元素结束，文档结束时，都将负责向外发送事件，而程序员负责提供事件监听器来监听这些事件，并通过事件来获取XML文档信息

- **JAXP的SAX支持**

  - JAXP为SAX解析器提供的API

    `SAXParser`和`SAXParserFactory`：`SAXParserFactory`工厂类的`newSAXParser()`实例方法用于创建`SAXParser`

  - `SAXParser`解析XML文档的方法

    - `void parse(InputStream is, DefaultHandler dh)`：使用指定dh作为监听器监听SAX解析事件，解析is输入流中的XML文档
    - `void parse(File f, DefaultHandler dh)`：使用指定dh作为监听器监听SAX解析事件，解析f文件所代表的XML文档
    - `void parse(InputSource is, DefaultHandler dh)`：使用指定dh作为监听器监听SAX解析事件，解析is输入源中的XML文档
    - ` void parse(String uri, DefaultHandler dh)`：使用指定dh作为监听器监听SAX解析事件，解析uri所代表的XML文档
    
  - SAX解析事件
  
    - ContentHandler：监听XML文档内容处理事件的监听器
    - DTDHandler：监听DTD处理事件的监听器
    - EntityResolver：监听实体处理事件的监听器
    - ErrorHandler：监听解析错误的监听器
  
  - JAXP提供了一个DefaultHandler类，实现了上述四个监听器的接口，并为接口中的方法提供了空实现
  
- **SAX解析XML文档**

  1. 创建SAX解析器工厂
  2. 创建SAX解析器
  3. 解析XML文档

  ```java
  //SAX.java
  import org.xml.sax.SAXException;
  import javax.xml.parsers.ParserConfigurationException;
  import javax.xml.parsers.SAXParser;
  import javax.xml.parsers.SAXParserFactory;
  import java.io.IOException;
  
  public class SAX{
      public static void main(String[] args) throws ParserConfigurationException, SAXException, IOException {		  //创建SAX解析器工厂		
          SAXParserFactory saxParserFactory=SAXParserFactory.newInstance();
          //创建SAX解析器
          SAXParser saxParser=saxParserFactory.newSAXParser();
          //调用SAX解析器的parser方法解析xml文档，需要提供一个继承了DefaultHandler类的自定义监听器
          saxParser.parse("C:\\Users\\Admin\\Desktop\\demo.xml",new Handler());
      }
  }
  ```

  ```java
  //Handler.java 监听器类
  import org.xml.sax.Attributes;
  import org.xml.sax.SAXException;
  import org.xml.sax.helpers.DefaultHandler;
  
  public class Handler extends DefaultHandler {
      //记录当前监听器当前监听的标签
      private String currTag;
      //扫描到文档开始时，监听器需要触发的方法
      @Override
      public void startDocument() throws SAXException {
         System.out.println("开始解析文档");
      }
  	//扫描到文档结束时，监听器需要触发的方法
      @Override
      public void endDocument() throws SAXException {
          System.out.println("解析文档结束");
      }
  	//扫描到文本时，监听器需要触发的方法
      @Override
      public void characters(char[] ch, int start, int length) throws SAXException {
          //将xml元素的文本转化为字符串
          String content=new String(ch,start,length);
          //判断xml元素是否含有文本
          if(content.trim().length()>0){
              System.out.println("<"+currTag+">元素的值是:"+content.trim());
          }
      }
  	//扫描到元素开始时，监听器需要触发的方法
      //qName表示该元素的元素名，attributes包含了该元素的所有属性名和属性值
      @Override
      public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
          currTag=qName;
          System.out.println("解析元素<"+qName+">开始");
          //判定该元素是否含有属性
          if(attributes.getLength()>0){
             System.out.println("元素<"+currTag+">属性如下:");
             for(int i=0;i<attributes.getLength();i++){
                 //打印元素的所有属性名及对应的值
                 System.out.println(attributes.getQName(i)+":"+attributes.getValue(i));
             }
          }
  
      }
  	//扫描到元素结束时，监听器需要触发的方法
      @Override
      public void endElement(String uri, String localName, String qName) throws SAXException {
          System.out.println("解析元素<"+qName+">结束");
      }
  }
  
  ```

- **SAX生成XML文档**

  1. 创建保存XML文档结果流对象
  2. 获取SAX生成工厂对象实例
  3. 获取SAX生成处理者对象实例
  4. 获取SAX生成器
  5. 生成文档及文档中的元素

  ```java
  import org.xml.sax.helpers.AttributesImpl;
  import javax.xml.transform.OutputKeys;
  import javax.xml.transform.Result;
  import javax.xml.transform.Transformer;
  import javax.xml.transform.TransformerConfigurationException;
  import javax.xml.transform.sax.SAXTransformerFactory;
  import javax.xml.transform.sax.TransformerHandler;
  import javax.xml.transform.stream.StreamResult;
  
  
  public class SAX {
      public static void main(String[] args) throws Exception {
          //创建保存XML文档结果流对象,用于保存生成的XML文档
          Result result=new StreamResult("C:\\Users\\Admin\\Desktop\\demo.xml");
          //获取SAX生成工厂对象实例
          SAXTransformerFactory saxTransformerFactory= (SAXTransformerFactory) SAXTransformerFac获取SAX生成处理者对象实例tory.newInstance();
          //获取SAX生成处理者对象实例
          TransformerHandler transformerHandler=saxTransformerFactory.newTransformerHandler();
          //设置SAX生成处理者对象实例生成的xml文档需要保存到的结果流对象
          transformerHandler.setResult(result);
          //获取SAX生成器
          Transformer transformer=transformerHandler.getTransformer();
          //设置生成器输出属性，文档中允许生成一些额外的空格
          transformer.setOutputProperty(OutputKeys.INDENT,"yes");
          //开始生成文档
          transformerHandler.startDocument();
          //生成开始元素书籍列表
          //new AttributesImpl()是元素属性的实例，若元素存在属性，可通过add方法进行添加
          transformerHandler.startElement("","","书籍列表",new AttributesImpl());
          //生成开始元素计算机书籍
          transformerHandler.startElement("","","计算机书籍",new AttributesImpl());
          //生成开始元素书名
          transformerHandler.startElement("","","书名",new AttributesImpl());
          //生成文本Spring
          transformerHandler.characters("Spring".toCharArray(),0,"Spring".length());
          //生成结束元素书名
          transformerHandler.endElement("","","书名");
          //生成结束元素计算机书籍
          transformerHandler.endElement("","","计算机书籍");
          //生成结束元素书籍列表
          transformerHandler.endElement("","","书籍列表");
          //结束生成文档
          transformerHandler.endDocument();
      }
  }
  ```

## 6.Servlet

### 6.1Servlet简介

全称Server Applet，称为小服务程序或服务连接器，用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容

### 6.2创建Servlet程序

创建一个Servlet程序首先需要配置Servlet的URL映射

- XML配置方式

  ```xml
  <!--web.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
      <!--配置servlet-->
      <servlet>
          <!--配置Servlet名称-->
          <servlet-name>LoginServlet</servlet-name>
          <!--配置Servlet对应的java类-->
          <servlet-class>demo.LoginServlet</servlet-class>
      </servlet>
      <!--配置Servlet映射-->
      <servlet-mapping>
          <!--需要配置映射的Servlet名称-->
          <servlet-name>LoginServlet</servlet-name>
          <!--配置URL映射，即在浏览器中访问这个Servlet的路径-->
          <url-pattern>/LoginServlet</url-pattern>
      </servlet-mapping>
  </web-app>
  ```

  ```java
  //LoginServlet.java
  package demo;
  
  import javax.servlet.ServletException;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  //Servlet类必须继承HttpServlet类
  public class LoginServlet extends HttpServlet {
      //当是post方法访问该Servlet时，此方法会被调用
      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          System.out.println("我是doPost方法");
      }
  	//当是get方法访问该Servlet时，此方法会调用
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          System.out.println("我是doGet方法");
      }
  }
  ```

- 注解配置方式

  ```java
  package demo;
  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  
  //使用@WebServlet注册Servlet，name即Servlet的名称，urlPatterns即Servlet的URL映射
  @WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
  public class LoginServlet extends HttpServlet {
      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          System.out.println("我是doPost方法");
      }
  
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          System.out.println("我是doGet方法");
      }
  }
  ```

### 6.3Servlet的生命周期

1. 初始化阶段调用`init()`方法（Servlet第一次被访问时调用）
2. 响应客户请求阶段调用`service()`方法（每次请求Servlet都会被调用）
3. 终止阶段调用`destroy()`方法（当Servlet被销毁时调用）

```java
//LoginServlet.java
package demo;
import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
public class LoginServlet extends HttpServlet {
    //第一次访问LoginServlet时调用
    @Override
    public void init(ServletConfig config) throws ServletException {
        System.out.println("Servlet被初始化了");
    }
	//每次请求LoginServlet都会被调用
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        System.out.println("Servlet被请求了");
    }
	//当LoginServlet被销毁时调用
    @Override
    public void destroy() {
        System.out.println("Servlet被销毁了");
    }
}
```

### 6.4请求与响应

- 浏览器对服务器的一次访问称为一次请求，在Servlet中请求用HttpServletRequest对象表示

  表单提交的数据都会被Servlet封装至HttpServletRequest对象，调用HttpServletRequest对象的getParameter()即可获得

- 服务器对浏览器的一次反馈称为一次响应，在Servlet中响应用HttpServletResponse对象表示

### 6.5ServletContext和ServletConfig

**ServletContext**：官方叫Servlet上下文。服务器会为每一个动态的Java Web工程创建一个对象，这个对象就是ServletContext对象。这个对象全局唯一，而且工程内部的所有Servlet都共享这个对象。所以叫全局应用程序共享对象。

```java
//LoginServlet.java
package demo;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //通过this.getServletContext()获取ServletContext对象，即该Servlet所在的工程对象
        ServletContext servletContext=this.getServletContext();
        //设置name属性，该属性共享于该工程下所有的Servlet
        servletContext.setAttribute("name","zwf");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        super.doPost(req, resp);
    }
}
```

```java
//Servlet.java
package demo;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "Servlet",urlPatterns = "/Servlet1")
public class Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        super.doPost(request, response);
    }
	
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //同属于一个工程，所以Servlet类和LoginServlet的ServletContext对象是同一个
        ServletContext servletContext=this.getServletContext();
        //获取共享的name属性
        System.out.println(servletContext.getAttribute("name"));

    }
}
```

**ServletConfig**：ServletConfig对象对应web.xml文件中的`<servlet>`元素。当服务器启动时，`<servlet>`元素中的一些配置信息会被封装到ServletConfig对象中

```xml
<!--web.xml-->
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <!--servlet标签中配置的信息都会被封装到ServletConfig对象中-->
    <servlet>
        <servlet-name>Servlet</servlet-name>
        <servlet-class>demo.Servlet</servlet-class>
        <!--设置初始化参数，web容器在创建Servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中-->
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
    </servlet>
    <servlet-mapping>
        <servlet-name>Servlet</servlet-name>
        <url-pattern>/Servlet1</url-pattern>
    </servlet-mapping>
</web-app>
```

```java
//Servlet.java
package demo;
import javax.servlet.ServletConfig;
import javax.servlet.ServletContext;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        super.doPost(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //this.getServletConfig()方法获取该Servlet的ServletConfig对象
        ServletConfig servletConfig=this.getServletConfig();
        //通过ServletConfig对象的getInitParameter方法获取web.xml中为Servlet配置的初始化参数
        String encoding=servletConfig.getInitParameter("encoding");
        System.out.println(encoding);
    }
}
```

### 6.6重定向与转发

区别：

- 实现转发调用的是HttpServletRequest对象的方法，而实现重定向调用的是HttpServletResponse对象的方法
- 转发时浏览器的url地址栏不会发生改变，重定向时浏览器的url地址会发生变化
- 转发时浏览器只请求服务器一次，重定向时浏览器请求服务器两次

```java
package demo;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@WebServlet(name = "Servlet",urlPatterns = "/Servlet1")
public class Servlet extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        super.doPost(request, response);
    }

    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        //若请求时带有参数isRedirect且为true时，则Servlet将重定向至页面index1.jsp
        if(Boolean.parseBoolean(request.getParameter("isRedirect"))){
            //重定向携带数据，需要使用ServletContext对象，因为两个不同的请求对象无法共享数据
            ServletContext servletContext=this.getServletContext();
            servletContext.setAttribute("name","重定向");
            //调用HttpServletResponse对象的sendRedirect()方法实现重定向，此时浏览器的url变更为http://localhost:8080/Servlet/index1.jsp
            response.sendRedirect("index1.jsp");
        }
        //否则Servlet将请求转发给index.jsp，浏览器的url不变
        else{
            //转发携带数据只需要使用HttpServletRequest，因为属于同一个请求对象
            request.setAttribute("name","转发");
            request.getRequestDispatcher("index.jsp").forward(request,response);
        }
    }
}
```

```jsp
<!--index1.jsp-->
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
<!--jsp本质上是一个Serlvet，application对象对应的就是Servlet中的ServletContext对象，所以可以实现数据的共享-->
<h1><%=application.getAttribute("name")%></h1>
</body>
</html>

<!--index.jsp-->
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
  <head>
    <title>Title</title>
  </head>
  <body>
<!--request对象对应Servlet中的HttpServletRequest对象-->
  <h1><%=request.getAttribute("name")%></h1>
  </body>
</html>
```

## 7.MVC

### 7.1MVC概述

**MVC**的全名是Model View Controller，是模型(Model)－视图(view)－控制器(controller)的缩写，是一种设计模式。它是用一种业务逻辑、数据与界面显示分离的方法来组织代码，将众多的业务逻辑聚集到一个部件里面

- 模型层（Model）：封装数据 
- 视图层（View）：展示数据
- 控制层（Controller）:接受请求并响应

### 7.2MVC工作流程

1. 用户通过View页面向服务端提出请求，可以是表单请求、超链接请求、AJAX请求等。
2. 服务端Controller控制器接收到请求后对请求进行解析，找到相应的Model对用户数据进行封装然后移交到业务层和持久层对与数据库进行交互
3. 业务层和持久层处理后，将处理结果再交给表现层的Controller
4. Controller在接到处理结果后，根据处理结果找到要作为向客户端发回的响应View页面。页面经渲染（数据填充）后，再发送给浏览器

### 7.3MVC案例

**JSP**+**Servlet**+**JavaBean**模式

- **JavaBean**作为模型层
- **JSP**作为视图层
- **Servlet**作为控制层

![image-20201106234631024](/static/img/image-20201106234631024.png)

### 7.4MVC应用

**实现web登录注册页面**

1. 项目结构

   ![image-20201107194449033](/static/img/image-20201107194449033.png)

   - 包Control：包含控制层的模块
     - LoginServlet.java：负责接收并处理来自登录页面的请求
     - RegisterServlet.java：负责接收并处理来自注册页面的请求
   - 包Model：包含模型层的模块
     - User.java：用于封装注册用户的信息
   - 目录web：包含显示层的模块
     - Index.jsp：显示登录成功后的页面
     - Login.jsp：显示登录的页面
     - Register.jsp：显示注册的页面
   - 包Util：包含持久层的模块
     - DBUtil：负责保存和处理用户相关信息
     - FileUploadUtil：负责用户头像上传的文件名处理
     - CookieUtil：负责保存用户的cookie信息

2. 核心代码实现

   **当页面向服务器提交的表单信息中包含文件时，则不能使用get方法，必须使用post方法，且表单的enctype属性要设置为multipart/form-data，此时无法通过request.getParameter方法获取表单项；与get方法不同，post方法上传的表单信息不会编码到URL的后面**

   案例采用apache的fileupload组件来接收和处理上传的文件，需要导入jar包commons.fileupload.jar

   ```java
   //Register.java
   package Control;
   import Model.User;
   import javax.servlet.ServletException;
   import javax.servlet.annotation.WebServlet;
   import javax.servlet.http.HttpServlet;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import java.io.FileOutputStream;
   import java.io.IOException;
   import java.io.InputStream;
   import java.io.OutputStream;
   import java.util.ArrayList;
   import java.util.HashMap;
   import java.util.List;
   import java.util.Map;
   import Util.DBUtil;
   import Util.FileUploadUtil;
   import org.apache.commons.fileupload.FileItem;
   import org.apache.commons.fileupload.FileUploadException;
   import org.apache.commons.fileupload.disk.DiskFileItemFactory;
   import org.apache.commons.fileupload.servlet.ServletFileUpload;
   
   //配置RegisterServlet的名字和url映射
   @WebServlet(name = "RegisterServlet",urlPatterns = "/RegisterServlet")
   public class RegisterServlet extends HttpServlet {
       //处理来自注册页面post方法的请求
       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           try {
               User user=new User();
               String path=null;
               Map<String, Object> map = new HashMap<>();
               List<String> hobbyList = new ArrayList<>();
               //创建一个磁盘文件项工厂
               DiskFileItemFactory diskFileItemFactory = new DiskFileItemFactory();
               //创建一个核心解析类,并将磁盘文件项工厂作为参数传入
               ServletFileUpload servletFileUpload = new ServletFileUpload(diskFileItemFactory);
               //解析request请求,返回一个元素是FileItem对象的列表,每一个FileItem对象都是表单中的信息
               List<FileItem> fileItemList = servletFileUpload.parseRequest(request);
               //遍历列表,获取每一个FileItem对象,判断是表单项还是文件上传项
               for (FileItem fileItem : fileItemList) {
                   //FileItem对象的isFormField()方法能判断该FileItem对象是否为表单项
                   if (fileItem.isFormField()) {
                       //普通表单项
                       //FileItem对象的getFieldName()方法获取当前表单项的name属性
                       String fieldName = fileItem.getFieldName();
                       //获得当前表单项的值
                       String fieldValue = fileItem.getString("UTF-8");
                       //判断当前表单项是否为复选框
                       if (fieldName.equals("hobby")) {
                           //用列表接收复选框的多个值
                           hobbyList.add(fieldValue);
                       } else {
                           //将表单项的name和值以键值对的形式存储
                           map.put(fieldName, fieldValue);
                       }
                   } else {
                       //文件上传项
                       //文件类型的input标签必须设置name属性,否则无法被FileItem对象的isFormField()方法判定为文件上传项
                       //FileItem对象的getName()方法获取上传的文件名
                       String fileName = fileItem.getName();
                       //判断用户是否上传了文件
                       if(!fileName.equals("")){
                           //若上传了文件
                           //将上传的文件名修改为随机的文件名,防止不同用户上传同名文件而被覆盖
                           String uniqFileName = FileUploadUtil.getUniqName(fileName);
                           //获得文件上传的数据
                           InputStream is = fileItem.getInputStream();
                           //设置文件上传到服务器的存放路径
                           path = this.getServletContext().getRealPath("/upload") + "\\" + uniqFileName;
                           //将输入流对接到输出流,即可将图片输出到服务器
                           //创建一个文件输出流对象,并将文件存放路径作为参数传入
                           OutputStream os = new FileOutputStream(path);
                           int len = 0;
                           byte[] b = new byte[1024];
                           while ((len = is.read(b)) != -1) {
                               os.write(b, 0, len);
                           }
                           //关闭输入流
                           is.close();
                           //关闭输出流
                           os.close();
                       }
                       else{
                           //若用户未上传文件
                         	//设置request对象的属性及值
                           request.setAttribute("img","未上传头像！");
                           //转发请求给注册页面,进行重新注册
                           request.getRequestDispatcher("Register.jsp").forward(request,response);
                       }
                   }
               }
               //判断用户名是否已注册
               if(DBUtil.isExist((String) map.get("account"))){
                   //若用户名已存在
                   //设置request对象的属性及值
                   request.setAttribute("msg","用户名已存在！");
                   //转发请求给注册页面,进行重新注册
                   request.getRequestDispatcher("Register.jsp").forward(request,response);
                   //并停止执行此方法
                   return;
               }
               else {
                   //若用户名不存在
                   //则取出map中的数据封装user对象,并存入DBUtil
                   map.put("hobby", hobbyList);
                   map.put("imgPath", path);
                   user.setAccount((String) map.get("account"));
                   user.setPassword((String) map.get("password"));
                   user.setNickname((String) map.get("nickname"));
                   user.setSex((String) map.get("sex"));
                   user.setHobby((List<String>) map.get("hobby"));
                   user.setImgPath((String) map.get("imgPath"));
                   DBUtil.add(user);
                   //重定向至登录页面,表示注册成功
                   response.sendRedirect("Login.jsp");
               }
           }catch (FileUploadException e) {
                   e.printStackTrace();
           }
       }
   
       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           super.doGet(request,response);
       }
   }
   ```
   
   ```java
   //LoginServlet.java
   package Control;
   import Model.User;
   import Util.DBUtil;
   import org.apache.commons.fileupload.FileItem;
   import org.apache.commons.fileupload.FileUploadException;
   import org.apache.commons.fileupload.disk.DiskFileItemFactory;
   import org.apache.commons.fileupload.servlet.ServletFileUpload;
   import javax.servlet.ServletException;
   import javax.servlet.annotation.WebServlet;
   import javax.servlet.http.Cookie;
   import javax.servlet.http.HttpServlet;
   import javax.servlet.http.HttpServletRequest;
   import javax.servlet.http.HttpServletResponse;
   import java.io.IOException;
   import java.util.HashMap;
   import java.util.List;
   import java.util.Map;
   
   @WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
   public class LoginServlet extends HttpServlet {
       protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           try {
               User user = new User();
               String account=request.getParameter("account");
          	 	String password=request.getParameter("password");
           	String remember=request.getParameter("remember");
               //通过登录页面上传的用户名和密码封装一个user对象
               user.setAccount(account);
               user.setPassword(password);
               //判断用户名或密码是否正确
               if(DBUtil.verify(user)){
                   //若正确
                   //则获取登录页面的记住用户名选项是否被勾选
                   if(Boolean.parseBoolean(remember)){
                       //若记住用户名选项被勾选,则创建Cookie对象,将用户名以键值对的方式作为参数传入
                       Cookie cookie=new Cookie("account",user.getAccount());
                       //设置Cookie对象的有效路径
                       cookie.setPath("/MVC");
                       //设置Cookie对象的有效时间,单位为秒,此时有效时间为1天
                       cookie.setMaxAge(60*60*24);
                       //让响应内容携带Cookie信息返回给浏览器
                       response.addCookie(cookie);
                   }
                   //将用户名存入session域中,以便于其他页面共享
                   request.getSession().setAttribute("user",DBUtil.getUser(user.getAccount()));
                   //若登录成功则重定向至Index页面
                   response.sendRedirect("Index.jsp");
               }
           } catch (FileUploadException e) {
               e.printStackTrace();
           }
       }
   
       protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
           super.doGet(request,response);
       }
   }
   ```

## 8.JSTL和EL表达式

- **EL表达式**
  全称**Expression Language** 表达式语言,常用于**取值**，目的是替代JSP页面中的复杂代码

  语法：`${}`

  ```jsp
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
      <title>Title</title>
  </head>
  <body>
  <!--传统jsp取值-->
  <%=request.getAttribute("attr")%>
  <!--EL表达式取值-->
  ${requestScope.attr}
  </body>
  </html>
  ```

  EL表达式从四大作用域中取值，即**page**，**request**，**session**，**application**作用域

  如果我们不指定作用域的话，直接**${attr}**的话，默认会按照**作用域的范围从小到大依次查找**，找到第一个为止，都找不到的话则为空
  作用域从小到大：**page->request->session->application**

  ```jsp
  <%--从 page 作用域中查找attr--%>
  ${pageScope.attr}
  <%--从 request 作用域中查找attr--%>
  ${requestScope.attr}
  <%--从 session 作用域中查找attr--%>
  ${sessionScope.attr}
  <%--从 application 作用域中查找attr--%>
  ${applicationScope.attr}
  ```

- **JSTL**

  全称**JavaSeverPages Standard Tag Libary**，JSP标准标签库，目的是为了减少JSP页面上的Java代码量，一般与EL表达式结合使用

  - **JSTL准备**

    需要导入jstl.jar和standard.jar，并在Schemas and DTDs中进行如下配置

    ![image-20201108180718262](/static/img/image-20201108180718262-1611019986856.png)

    ```jsp
    <%@ page contentType="text/html;charset=UTF-8" language="java" %>
    <!--要想在jsp页面中使用jstl，必须设置如下指令，引用核心标签库-->
    <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
    <html>
    <head>
        <title>Title</title>
    </head>
    <body>
    </body>
    </html>
    ```

  - **语法**：`<prefix:标签名/>`或`<prefix:标签名><prefix:标签名/>`（prefix为引用标签库时设置的值）

  - **JSTL通用标签**

    - set标签：设置属性和值保存到指定域里

      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <!--set标签-->
      <!--var的值表示设置的属性名，value的值表示属性名对应的属性值，scope的值表示属性需要存放的域-->
      <!--此处将属性保存到page域中-->
      <c:set var="name" value="123" scope="page"/>
      </body>
      </html>
      ```

    - out标签：将结果输出显示

      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <!--out标签-->  
      <!--value的值表示要输出到页面的内容-->  
      <!--此处与EL表达式搭配使用，输出page域下的name属性值-->    
      <c:out value="${pageScope.name}"/>
      </body>
      </html>
      ```
      
    - remove标签：删除指定域内数据
    
      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <!--remove标签-->  
      <!--var的值表示要删除的属性的名称，scope的值表示需要删除的属性所在的域--> 
      <!--此处删除page域下的name属性-->
      <c:remove var="name" scope="page"/>
      </body>
      </html>
      ```
    
  - **JSTL条件标签**
  
    - if标签：逻辑的判断
  
      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <!--设置name属性，值为zwf，域为page-->
      <c:set var="name" value="zwf" scope="page"/>
      <!--if标签-->    
      <!--test的值表示判断的条件，若test为true，则执行if标签里的内容-->    
      <c:if test="${pageScope.name=='zwf'}">
          <c:out value="${pageScope.name}"/>
      </c:if>
      </body>
      </html>
      ```
  
    - choose标签：条件的选择（相当于java代码的switch语句）
  
      choose标签要和when标签，otherwise标签一同使用
  
      1.  使用choose标签声明 ，相当于switch声明
      2.  使用when标签做判断，相当于case
      3.  使用otherwise标签做其他情况的声明，相当于default
  
      ```jsp
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <!--设置number属性，值为2，域为page-->
      <c:set var="number" value="2" scope="page"/>
      <!--choose标签-->
      <!--选择当number的值为1-7之间的数字，则输出相应的中文，否则输出错误-->    
      <c:choose>
          <!--when标签-->
          <!--test的值表示判断的条件，若test为true，则执行when标签里的内容-->    
          <c:when test="${number=='1'}">一</c:when>
          <c:when test="${number=='2'}">二</c:when>
          <c:when test="${number=='3'}">三</c:when>
          <c:when test="${number=='4'}">四</c:when>
          <c:when test="${number=='5'}">五</c:when>
          <c:when test="${number=='6'}">六</c:when>
          <c:when test="${number=='7'}">七</c:when>
          <!--otherwise标签-->
          <!--当以上所有when标签不成立时，就会执行otherwise标签中的内容-->
          <c:otherwise>错误</c:otherwise>
      </c:choose>
      </body>
      </html>
      ```
  
  - **JSTL迭代标签**
  
    - forEach标签：循环
  
      ```jsp
      <%@ page import="java.util.List" %>
      <%@ page import="java.util.ArrayList" %>
      <%@ page contentType="text/html;charset=UTF-8" language="java" %>
      <%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
      <html>
      <head>
          <title>Title</title>
      </head>
      <body>
      <%
          List<Integer> list=new ArrayList<>();
          for(int i=0;i<10;i++){
              list.add(i);
          }
          //在request域中添加一个列表
          request.setAttribute("list",list);
      %>
      <!--forEach标签-->    
      <!--items的值表示要遍历的集合，var的值表示迭代参数名称，即每一次迭代后获得的集合的值--> 
      <c:forEach var="item" items="${list}">
          <!--forEach标签每一次迭代获得集合中的值，用var对应的迭代参数进行保存，并将迭代参数存放到page作用域中-->
          ${item}
      </c:forEach>
      </body>
      </html>
      ```

## 9.JQuery

- **概述**

  JQuery 是一个 JavaScript 库， 极大地简化了 JavaScript 编程
  
- **JQuery语法**

  - **符号$**

    **$**相当于JQuery的别名，本质上是一个JQuery对象，同时也是一个函数，可以把**$**符号理解为**“选取”**的意思

    **$**用作函数的实例：

    1. `$(function (){})`：参数为一个function，作为入口函数使用（即等待DOM文档加载完成后执行的函数）
    2. `$(domobj)`：参数为一个DOM对象，用于将DOM对象转化为JQuery对象
    3. `$("div")`：参数是一个字符串，用于查找对应的标签并转化为一个JQuery对象返回

    **$**用作JQuery对象实例：

    1. `$.ajax()`：调用JQuery内置的ajax方法

  - **JQuery选择器**
    JQuery 选择器基于元素的 id、类、类型、属性、属性值等"查找"（或选择）HTML 元素

    JQuery 中所有选择器都以美元符号开头：`$()`

    1. 元素选择器

       `$("p")`：选取页面中所有的`<p>` 元素

    2. id选择器

       `$("#test")`：选取页面中id为test的元素

    3. 类选择器

       `$(".test")`：选取页面中class为test的元素

- **JQuery事件**

  在 JQuery 中，大多数 DOM 事件都有一个等效的 JQuery 方法

  - **绑定事件**

    `$("p").click();`：调用JQuery的`click()`方法为页面的所有p元素绑定一个点击事件

  - **触发事件**

    `$("p").click(function(){//动作触发后执行的代码});`：通过给`click()`方法传入一个匿名函数，来指定事件触发后要执行的效果

  - **常用的 JQuery 事件方法**

    `$(document).ready(function(){//动作触发后执行的代码})`：在文档完全加载完后执行函数ready中的代码

## 10.Ajax

### 10.1Ajax概述

全称 **Asynchronous JavaScript and XML(异步的 JavaScript 和 XML)**， 是一种用于创建快速动态网页的技术

- **Ajax特点**
  - 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新
  - 传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页

### 10.2Ajax实现局部刷新

- **JQuery实现**

  JQuery内置了ajax方法：`$.ajax(url,options)`

  - `$.ajax(url,options)`主要参数详解：
    - **url**：要求为String类型参数，**表示要请求的服务器地址（默认为当前页地址）**
    - **type**：要求为String类型的参数，请求方式（post或get）默认为get，**表示请求目的服务器的方式**
    - **timeout**：要求为Number类型的参数，**表示设置请求超时时间（毫秒）**。此设置将覆盖$.ajaxSetup()方法的全局设置。
    - **async**：要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
    - **cache**：要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。
    - **data**：要求为Object或String类型的参数，**表示要发送到服务器的数据**。如果已经不是字符串，将自动转换为字符串格式。如果是get方式请求服务器，则data数据会转化为字符串附加在url后。对象必须为key/value格式，例如`{foo1:"bar1",foo2:"bar2"}`转换为`&foo1=bar1&foo2=bar2`。如果是数组，JQuery将自动为不同值对应同一个名称。例如`{foo:["bar1","bar2"]}`转换为`&foo=bar1&foo=bar2`。
    - **dataType**：要求为String类型的参数，**表示预期服务器返回的数据类型**。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为`success`指定的回调函数的参数传递。可用的类型如下：
      - xml：返回XML文档，可用JQuery处理。
      - html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。
      - script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。
      - json：返回JSON数据。
      - jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。
      - text：返回纯文本字符串。
    - **success**：要求为Function类型的参数，**表示请求成功后调用的回调函数**，有两个参数：
      - 由服务器返回，并根据dataType参数进行处理后的数据。
      - 描述状态的字符串。

  ```jsp
  <!--Login.jsp-->
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <%
    String basePath=request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+request.getContextPath()+"/";
    application.setAttribute("basePath",basePath);
  %>
  <head>
    <title>登录页面</title>
    <link rel="stylesheet" type="text/css" href="css/Login.css">
    <script type="text/javascript" src="js/jquery-3.5.1.min.js"></script>
  </head>
  <body>
  <div class="login-box">
    <div class="top">
      <div class="login">
        <a href="javascript:void(0)">登录</a>
      </div>
    </div>
    <div class="mid">
      <table>
        <tr>
          <td>
            用户名
          </td>
          <td>
            <label>
              <input class="area" type="text" name="account">
            </label>
          </td>
        </tr>
        <tr>
          <td>
            密码
          </td>
          <td>
            <label>
              <input class="area" type="password" name="password">
            </label>
          </td>
        </tr>
      </table>
      <span class="tip"></span>
    </div>
    <div class="bottom">
      <input type="submit" value="登录" id="submit">
    </div>
  </div>
  </body>
  <script>
    //在文档加载完成后执行  
    $(document).ready(function () {
     	//获取id为submit的元素，即登录按钮，并为其绑定点击事件，
      $("#submit").click(function () {
        //当点击登录按钮时，触发事件，调用$.ajax方法，实现局部刷新效果
        $.ajax({
          //设置请求的服务器地址   
          url:"${basePath}LoginServlet",
          //设置请求方式为post  
          type:"post",
          //设置向服务器提交的数据，此处data的值为object类型
          data:{
            "account":$("input[name='account']").val(),
            "password":$("input[name='password']").val()
          },
          //设置服务器返回的数据类型为json  
          dataType:"json",
          //设置请求成功后的回调函数  
          //回调函数的result参数接收服务器返回的数据，status参数接收描述是否成功请求服务器的状态字符串
          success:function (result,status) {
            //返回的json被转化为object类型
            //获取其中的flag属性  
            var flag=result.flag;
            //若flag为true，则表示登录成功  
            if(flag){
              //location.href将当前页面url定位到Index.jsp
              location.href="Index.jsp";
            }
            //若flag为false  
            else{
              //则获取类为tip的元素，向其中文本输出提示  
              $(".tip").text("用户名或密码错误！");
            }
          }
        });
      })
    });
  </script>
  </html>
  ```

  ```java
  //服务器端 LoginServlet.java
  package Control;
  import Model.User;
  import Util.DBUtil;
  import org.json.JSONObject;
  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.nio.charset.StandardCharsets;
  
  @WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
  public class LoginServlet extends HttpServlet {
      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          //获取客户端传来的用户名和密码
          String account=request.getParameter("account");
          String password=request.getParameter("password");
          User user = new User();
          user.setAccount(account);
          user.setPassword(password);
          JSONObject json;
          //判断用户名和密码是否正确
          if(DBUtil.verify(user)){
              //正确，则将该User对象存入session域中
              request.getSession().setAttribute("user",DBUtil.getUser(user.getAccount()));
              //并将json字符串'{flag:true}'转化为json对象
              json=new JSONObject("{flag:true}");
          }
          else{
              //否则将json字符串'{flag:false}'转化为json对象
              json=new JSONObject("{flag:false}");
          }
          //获取响应的输出流，通过输出流的write方法，将json对象转化为二进制字节流数据输出给客户端
          response.getOutputStream().write(json.toString().getBytes(StandardCharsets.UTF_8));
      }
  
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          doPost(request,response);
      }
  }
  ```

- **原生JS实现**

  原生JS是通过XmlHttpRequest对象来实现Ajax

  - XmlHttpRequest对象的方法

    - `open(method,url,async)`：设置请求的相关信息

      - 参数**method**要求为String类型，**表示请求服务器的方式**，get或post
      - 参数**url**要求为String类型，**表示请求的服务器地址**
      - 参数**async**要求为Boolean类型，**表示是否异步请求**，默认为true，异步请求

    - `send(body)`：发送请求

      - 参数**body**为可选，**表示要向服务器发送的数据**，可以是:

        1. 可以为 [`Document`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document), 在这种情况下，它在发送之前被序列化.
        2. 为 `XMLHttpRequestBodyInit`, 从 [per the Fetch spec](https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit) （规范中）可以是 [`Blob`](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob), [`BufferSource`](https://developer.mozilla.org/zh-CN/docs/Web/API/BufferSource), [`FormData`](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData), [`URLSearchParams`](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams), 或者 [`USVString`](https://developer.mozilla.org/zh-CN/docs/Web/API/USVString) 对象.
        3. `null`

        如果body没有指定值，则默认值为 `null` .

    - `setRequestHeader(name,value)`：设置请求头中指定属性的值。在设置任何请求头属性之前必须先调用open()方法

  - XmlHttpRequest对象的属性：

    - `responseText `：从服务器端返回的文本
    - `readyState`：表示当前请求的状态
      - 值为0：请求被创建，但尚未调用 open() 方法。
      - 值为1：`open()` 方法已经被调用。
      - 值为2：`send()` 方法已经被调用，并且头部和状态已经可获得。
      - 值为3：下载中； `responseText` 属性已经包含部分数据
      - 值为4：下载操作已完成。
    - `status`：服务器的HTTP状态码（200对应OK、404对应NOtFont等）

  - XmlHttpRequest对象的事件

    - `onreadystatechange`：只要 `readyState` 属性发生变化，就会调用相应的处理函数

  ```jsp
  <!--Login.jsp-->
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <%
    String basePath=request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+request.getContextPath()+"/";
    application.setAttribute("basePath",basePath);
  %>
  <head>
    <title>登录页面</title>
    <link rel="stylesheet" type="text/css" href="css/Login.css">
    <script type="text/javascript" src="js/jquery-3.5.1.min.js"></script>
  </head>
  <body>
  <div class="login-box">
    <div class="top">
      <div class="login">
        <a href="javascript:void(0)">登录</a>
      </div>
    </div>
    <div class="mid">
      <table>
        <tr>
          <td>
            用户名
          </td>
          <td>
            <label>
              <input class="area" type="text" name="account">
            </label>
          </td>
        </tr>
        <tr>
          <td>
            密码
          </td>
          <td>
            <label>
              <input class="area" type="password" name="password">
            </label>
          </td>
        </tr>
      </table>
      <span class="tip"></span>
    </div>
    <div class="bottom">
      <input type="submit" value="登录" id="submit">
    </div>
  </div>
  </body>
  <script>
    //获取登录按钮    
    var submit=document.getElementById("submit")
    //当登录按钮被点击，触发事件，完成ajax操作  
    submit.onclick=function () {
      //创建一个XMLHttpRequest对象
      var xhr=new XMLHttpRequest();
      //获取用户名  
      var account=document.getElementsByClassName("area")[0];
      //获取密码  
      var password=document.getElementsByClassName("area")[1];
      //获取显示提示信息的元素  
      var tip=document.getElementsByClassName("tip")[0];
      //设置XMLHttpRequest对象的请求信息
      //若请求方式为get，可以直接将要传输的数据以参数的形式附加到url后  
      xhr.open("post","${basePath}LoginServlet",true);
      //采用URLSearchParams格式构造向服务器传输的数据
      var data="account="+account.value+"&password="+password.value;
      //由于采用post方式请求，所以要设置请求头中的Content-Type属性为application/x-www-form-urlencoded
      //这样服务器端才能通过request.getParameter()方法获取数据  
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      //发送请求  
      xhr.send(data);
      //当XMLHttpRequest对象的readyState属性值变化时，触发事件
      xhr.onreadystatechange=function () {
        //当readyState属性值为4且响应状态码为200时，才能表示成功完成ajax请求 
        if(xhr.readyState==4&&xhr.status==200){
          //若服务器端返回的文本不为空字符串  
          if(xhr.responseText!==""){
            //则往tip元素内实现局部刷新  
            tip.innerHTML=xhr.responseText;
          }
          else {
            //否则定位到Index.jsp页面 
            location.href="Index.jsp";
          }
        }
      }
    }
  </script>
  </html>
  ```

  ```java
  //服务器端 LoginServlet.java
  package Control;
  import Model.User;
  import Util.DBUtil;
  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  import java.nio.charset.StandardCharsets;
  
  @WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
  public class LoginServlet extends HttpServlet {
      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          String account=request.getParameter("account");
          String password=request.getParameter("password");
          User user = new User();
          user.setAccount(account);
          user.setPassword(password);
          String tip="";
          if(DBUtil.verify(user)){
              request.getSession().setAttribute("user",DBUtil.getUser(user.getAccount()));
          }
          else{
              tip="用户名或密码错误！";
          }
          response.getOutputStream().write(tip.getBytes(StandardCharsets.UTF_8));
      }
  
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          doPost(request,response);
      }
  }
  ```

## 11.过滤器

### 11.1过滤器概述

过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理

- **过滤器的工作流程**：![img](https://img-blog.csdn.net/20180730175152255?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1emhpcWlhbmdfMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)
- **过滤器的生命周期**：
  - web应用程序启动时，web服务器创建Filter的实例对象，以及对象的初始化
  - 当请求访问与过滤器关联的web资源时，过滤器拦截请求，完成指定功能
  - Filter对象创建后会驻留在内存中，直到web应用移除或服务器停止时，才会销毁
- **过滤器链**：
  - 在一个web应用中，多个过滤器组合起来，称为过滤器链
  - 过滤器的调用顺序：
    - XML配置下：取决于过滤器在web.xml中`<filter-mapping>`的顺序
    - 注解配置下：取决于过滤器的类名字符排序

### 11.2创建过滤器

- XML配置方式

  ```xml
  <!--web.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
      <!--配置过滤器-->
      <filter>
          <!--配置过滤器名称-->
          <filter-name>Filter</filter-name>
          <!--配置过滤器对应的类-->
          <filter-class>Filter.Filter</filter-class>
      </filter>
      <!--配置过滤器拦截映射-->
      <filter-mapping>
          <!--需要配置映射的过滤器名称-->
          <filter-name>Filter</filter-name>
          <!--配置url映射，当访问满足该映射的web资源时，过滤器就会被调用-->
          <url-pattern>/index.jsp</url-pattern>
      </filter-mapping>
  </web-app>
  ```

  ```java
  package Filter;
  import javax.servlet.*;
  import java.io.IOException;
  //要创建一个过滤器，只需实现javax.servlet.Filter接口，并实现里面的方法
  public class Filter implements javax.servlet.Filter {
      //过滤器销毁时调用
      public void destroy() {
      }
  	//当符合要求的请求被拦截时调用
      public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
          //chain.doFilter方法将请求转发给下一个过滤器
          chain.doFilter(req, resp);
      }
  	//过滤器初始化时调用
      //参数config为FilterConfig对象，对应web.xml中的<filter>元素
      //当过滤器初始化时,会将web.xml中的<filter>元素的配置信息封装传给FilterConfig对象
      //可以通过调用config的一些方法获取初始化参数,过滤器名称等
      public void init(FilterConfig config) throws ServletException {
  
      }
  }
  ```

- 注解配置方式

  ```java
  package Filter;
  
  import javax.servlet.*;
  import javax.servlet.annotation.WebFilter;
  import java.io.IOException;
  //@WebFilter可以将java类注册为过滤器，filterName表示过滤器名称，urlPatterns表示过滤器的要拦截的url映射
  @WebFilter(filterName = "Filter",urlPatterns = "/index.jsp")
  public class Filter implements javax.servlet.Filter {
      public void destroy() {
      }
  
      public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {
          chain.doFilter(req, resp);
      }
  
      public void init(FilterConfig config) throws ServletException {
  
      }
  
  }
  ```

### 11.3过滤器应用

- **解决网页中文乱码问题**

  - Web中乱码产生的原因：

    - 发送方要发送一串字符，首先必须用字符集给它编码（encode）变成2进制传输，接收方需要用同一个字符集进行解码（decode）方才能知道发送方发送的内容。如果双方所用的字符集不一致就会产生乱码。
    - Web交互中的request中的发送方是客户端，接收方是服务端。**发送方默认使用ISO-8859-1来编码发送的内容**，所以当我们在服务端调用`request.getCharacterEncoding()`方法返回的永远是`null`，因为发送内容的编码是由客户端指定，服务端是不知道的

  - 解决办法：

    采用过滤器

    ```java
    package Filter;
    
    /**
     * 字符集编码过滤器
     */
    
    import javax.servlet.Filter;
    import javax.servlet.*;
    import javax.servlet.annotation.WebFilter;
    import java.io.IOException;
    @WebFilter(filterName = "CEF",urlPatterns = "/*")
    public class CharacterEncodingFilter implements Filter {
    
       @Override
       public void destroy() {
    
       }
    	//此过滤器可用于解决post乱码的问题
       @Override
       public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
             throws IOException, ServletException {
          //拦截请求，并设置字符编码集，覆盖默认的ISO-8859-1编码集
          request.setCharacterEncoding("UTF-8");
          chain.doFilter(request, response);
    
       }
    
       @Override
       public void init(FilterConfig config) throws ServletException {
    
       }
    
    }
    ```

- **对用户访问权限控制**

  - 访问权限：

    当用户在网站中未登录，必须限制用户的访问权限，即用户未登录是无法访问登录后的页面

  - 解决办法：

    采用过滤器

    ```java
    package filter;
    
    import java.io.IOException;
    
    import javax.servlet.Filter;
    import javax.servlet.FilterChain;
    import javax.servlet.FilterConfig;
    import javax.servlet.ServletException;
    import javax.servlet.ServletRequest;
    import javax.servlet.ServletResponse;
    import javax.servlet.annotation.WebFilter;
    import javax.servlet.http.HttpServletRequest;
    import javax.servlet.http.HttpServletResponse;
    
    @WebFilter(filterName = "SessionFilter",urlPatterns = "/*")
    public class SessionFilter implements Filter {
    
    	@Override
    	public void destroy() {
    
    	}
    
    	@Override
    	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
    			throws IOException, ServletException {
    
    		HttpServletRequest hrequest = (HttpServletRequest) request;// 涉及到HTTP请求处理，转型处理
    		HttpServletResponse hresponse = (HttpServletResponse) response;// 涉及到HTTP请求处理，转型处理
    
    		String loginUser = (String) hrequest.getSession().getAttribute("loginUser");// 判断用户是否完成了登录操作，session中是否存储用户名
    
    		if (loginUser == null) {
    			hresponse.sendRedirect(hrequest.getContextPath() + "/index.jsp?flag=1");// 未登录，系统强制重定向至登录页面
    			return;
    		} else {
                //若登录，则移交给下个过滤器处理
    			chain.doFilter(hrequest, hresponse);
    			return;
    		}
    
    	}
    
    	@Override
    	public void init(FilterConfig config) throws ServletException {
    
    	}
    
    }
    ```

### 11.4过滤器中的dispatcher元素解析

`<dipatcher>`元素是`<filter-mapping>`元素的子元素，**定义了客户端以什么形式访问与过滤器关联的资源才会触发拦截**

`<dipatcher>`元素有四个值：

- REQUEST（`<dipatcher>`的缺省值）：只要发起的操作是一次HTTP请求，比如请求某个URL、发起了一个GET请求、表单提交方式为POST的POST请求、表单提交方式为GET的GET请求。一次重定向则前后相当于发起了两次请求，这些情况下有几次请求就会走几次指定过滤器

- FORWARD：只有当当前页面是通过请求转发转发过来的情形时，才会走指定的过滤器 

- INCLUDE：只要是通过`<jsp:include page="xxx.jsp" />`，嵌入进来的页面，每嵌入的一个页面，都会走一次指定的过滤器。

- ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器被调用

  ```xml
  <!--web.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
      <filter>
          <filter-name>Filter</filter-name>
          <filter-class>Filter.Filter</filter-class>
      </filter>
      <filter-mapping>
          <filter-name>Filter</filter-name>
          <url-pattern>/dd.jsp</url-pattern>
          <dispatcher>ERROR</dispatcher>
      </filter-mapping>
      <!--配置错误处理页面-->
      <error-page>
          <!--当页面出现404错误-->
          <error-code>404</error-code>
          <!--都会定位到该页面，若过滤器与该页面关联，则会被调用-->
          <location>/dd.jsp</location>
      </error-page>
  </web-app>
  ```

可以通过设置多个`<dipatcher>`子元素，来实现过滤器拦截多个特定调用形式的请求

## 12.监听器

### 12.1监听器概述

- Servlet规范定义的一种特殊类
- 用于监听ServletContext、HttpSession、ServletRequest等域对象的创建，销毁及属性修改发生变化的事件
- 监听器可以在事件发生前后进行一些必要的处理操作

![image-20201111183019103](/static/img/image-20201111183019103.png)

### 12.2创建监听器

- 注解配置方式

  ```java
  //FirstListener.java
  package Listener;
  
  import javax.servlet.ServletContextEvent;
  import javax.servlet.ServletContextListener;
  import javax.servlet.annotation.WebListener;
  import javax.servlet.http.HttpSessionAttributeListener;
  import javax.servlet.http.HttpSessionEvent;
  import javax.servlet.http.HttpSessionListener;
  import javax.servlet.http.HttpSessionBindingEvent;
  //@WebListener()可以将当前类注册为监听器
  @WebListener()
  //该监听器实现了三个常用的监听器接口ServletContextListener,HttpSessionListener, HttpSessionAttributeListener
  public class FirstListener implements ServletContextListener,
          HttpSessionListener, HttpSessionAttributeListener {
      
      public FirstListener() {
      }
  
  	//ServletContex域的监听器方法实现
      //当ServletContext被创建时，该方法被调用
      public void contextInitialized(ServletContextEvent sce) {
     
      }
  	//ServletContex域的监听器方法实现
      //当ServletContext被销毁时，该方法被调用
      public void contextDestroyed(ServletContextEvent sce) {
      }
  
      //HttpSession域的监听器方法实现
      //当HttpSession被创建时，该方法被调用
      public void sessionCreated(HttpSessionEvent se) {
      }
  	//HttpSession域的监听器方法实现
      //当HttpSession被销毁时，该方法被调用        
      public void sessionDestroyed(HttpSessionEvent se) {
      }
      
      //HttpSession域属性的监听器方法实现
      //当HttpSession添加属性时，该方法被调用        
      public void attributeAdded(HttpSessionBindingEvent sbe) {
      }
  	//HttpSession域属性的监听器方法实现
      //当HttpSession移除属性时，该方法被调用          
      public void attributeRemoved(HttpSessionBindingEvent sbe) {
      }
  	//HttpSession域属性的监听器方法实现
      //当HttpSession的属性被替代时，该方法被调用 
      public void attributeReplaced(HttpSessionBindingEvent sbe) {
      }
  }
  ```

  **存在多个监听器时，启动顺序按照监听器类名称字符排序**

- XML配置方式

  ```xml
  <!--web.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
  	<!--配置监听器-->
      <listener>
          <!--配置监听器对应的类路径-->
          <listener-class>Listener.FirstListener</listener-class>
      </listener>
  </web-app>
  ```

  ```java
  //FirstListener.java
  package Listener;
  
  import javax.servlet.ServletContextEvent;
  import javax.servlet.ServletContextListener;
  import javax.servlet.http.HttpSessionAttributeListener;
  import javax.servlet.http.HttpSessionEvent;
  import javax.servlet.http.HttpSessionListener;
  import javax.servlet.http.HttpSessionBindingEvent;
  
  public class FirstListener implements ServletContextListener,
          HttpSessionListener, HttpSessionAttributeListener {
  
      public FirstListener() {
      }
  
  
      public void contextInitialized(ServletContextEvent sce) {
  
      }
  
      public void contextDestroyed(ServletContextEvent sce) {
  
      }
  
      public void sessionCreated(HttpSessionEvent se) {
        
      }
  
      public void sessionDestroyed(HttpSessionEvent se) {
  
      }
  
   
      public void attributeAdded(HttpSessionBindingEvent sbe) {
   
      }
  
      public void attributeRemoved(HttpSessionBindingEvent sbe) {
      }
  
      public void attributeReplaced(HttpSessionBindingEvent sbe) {
      }
  }
  ```

  **存在多个监听器时，启动顺序按照监听器在web.xml中的配置顺序**

### 12.3监听器分类

- 按监听对象分类
  - ServletContext对象监听器
  - HttpSession对象监听器
  - ServletRequest对象监听器
- 按监听事件分类
  -  域对象自身创建和销毁事件监听器
  - 域对象属性添加、替代和移除事件监听器
  - 绑定到session中的某个对象的状态事件监听器

### 12.4监听器应用

- **ServletContextListener**

  使用ServletContextListener监听器监听ServletContext的生命周期，获取ServletContext的相关配置信息

  ```java
  //ServletContext域的监听器
  package Listener;
  import javax.servlet.ServletContextEvent;
  import javax.servlet.ServletContextListener;
  import javax.servlet.annotation.WebListener;
  @WebListener()
  public class FirstListener implements ServletContextListener{
  
      public FirstListener() {
      }
      //ServletContext对象创建调用
      public void contextInitialized(ServletContextEvent sce) {
          //获取web.xml中ServletContext对象配置的初始化参数
          String version=sce.getServletContext().getInitParameter("version");
          sce.getServletContext().setAttribute("version",version);
      }
  
      public void contextDestroyed(ServletContextEvent sce) {
      }
  
  }
  ```

  ```xml
  <!--web.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
  <!--配置ServletContext的初始化参数-->
  <context-param>
      <param-name>version</param-name>
      <param-value>1.0</param-value>
  </context-param>
  </web-app>
  ```

- **HttpSessionListener**

  使用HttpSessionListener监听器监听HttpSession的生命周期，获取Session的相关配置信息

  ```java
  //HttpSession域的监听器
  package Listener;
  import javax.servlet.annotation.WebListener;
  import javax.servlet.http.HttpSessionEvent;
  import javax.servlet.http.HttpSessionListener;
  import java.util.Date;
  
  @WebListener()
  public class FirstListener implements HttpSessionListener {
  
      public FirstListener() {
      }
  	//当HttpSession对象创建时调用
      @Override
      public void sessionCreated(HttpSessionEvent se) {
          //获取HttpSession对象的id
          String sessionId=se.getSession().getId();
          //获取HttpSession对象的创建时间
          Date createTime=new Date(se.getSession().getCreationTime());
          System.out.println(sessionId+":"+createTime);
      }
  	//当HttpSession对象被销毁时调用
      @Override
      public void sessionDestroyed(HttpSessionEvent se) {
          System.out.println("destroy...");
      }
  }
  ```

  ```xml
  <!--web.xml-->
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
           version="4.0">
  <!--配置HttpSession的相关信息-->
  <session-config>
      <!--配置HttpSession对象的失效时间，单位为分钟，即1分钟后session会被销毁-->
      <session-timeout>1</session-timeout>
  </session-config>
  </web-app>
  ```

- **ServletRequestListener**
  使用ServletRequestListener监听器监听ServletRequest的生命周期，获取ServletRequest的相关配置信息

  ```java
  package Listener;
  import javax.servlet.ServletRequestEvent;
  import javax.servlet.ServletRequestListener;
  import javax.servlet.annotation.WebListener;
  import javax.servlet.http.HttpServletRequest;
  
  @WebListener()
  public class FirstListener implements ServletRequestListener {
  
      public FirstListener() {
      }
  	//ServletRequest对象被创建时调用
      @Override
      public void requestInitialized(ServletRequestEvent sre) {
          //获取ServletRequest，强转为HttpServletRequest
          HttpServletRequest hsr= (HttpServletRequest) sre.getServletRequest();
          //获取请求路径
          String uri=hsr.getRequestURI();
          //获取请求参数
          String param=hsr.getParameter("name");
          System.out.println(uri+" "+param);
      }
  	//请求完成后，ServletRequest就会被销毁
      @Override
      public void requestDestroyed(ServletRequestEvent sre) {
          System.out.println("destroy...");
      }
  }
  ```

- **ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener**

  以ServletContextAttributeListener为例，当监听到ServletContext的属性发生添加、替换或移除事件时，可以通过监听器做出相应操作
  
  ```java
  package Listener;
  import javax.servlet.ServletContextAttributeEvent;
  import javax.servlet.ServletContextAttributeListener;
  import javax.servlet.annotation.WebListener;
  
  @WebListener()
  public class FirstListener implements ServletContextAttributeListener {
  
      public FirstListener() {
      }
  	//ServletContext添加属性时调用
      @Override
      public void attributeAdded(ServletContextAttributeEvent scae) {
          //获取添加的属性名和值
          String attrName=scae.getName();
          Object attrValue=scae.getValue();
          System.out.println(attrName+":"+attrValue);
      }
  	//ServletContext移除属性时调用
      @Override
      public void attributeRemoved(ServletContextAttributeEvent scae) {
          //获取移除的属性名和值
          String attrName=scae.getName();
          Object attrValue=scae.getValue();
          System.out.println(attrName+":"+attrValue);
      }
  	//ServletContext替换属性时调用
      @Override
      public void attributeReplaced(ServletContextAttributeEvent scae) {
          //获取替代的属性名和值
          String attrName=scae.getName();
          Object attrValue=scae.getValue();
          System.out.println("r"+attrName+":"+attrValue);
      }
  }
  ```
  
- **HttpSessionBindingListener**

  HttpSessionBindingListener监听器用于监听HttpSession的绑定和解绑事件

  ```java
  import javax.servlet.annotation.WebListener;
  import javax.servlet.http.*;
  
  @WebListener()
  public class Listener implements HttpSessionBindingListener {
  
      public Listener() {
      }
  	//当HttpSession对象添加属性时，该方法被调用
      @Override
      public void valueBound(HttpSessionBindingEvent event) {
          System.out.println(event.getName());
      }
  	//当HttpSession对象移除属性时，该方法被调用
      @Override
      public void valueUnbound(HttpSessionBindingEvent event) {
  		 System.out.println(event.getName());
      }
  }
  ```

### 12.5监听器实现登录限制案例

**登录限制**：不能多个人同时登录一个账号

**原理**：当用户登录一个已经在线的账号，网站会将当前在线账号持有的Session对象销毁，实现强制注销的功能

**代码实现**：

- 用户信息表和Session的映射

  ![image-20201111230609271](/static/img/image-20201111230609271.png)

- 用户信息存储代码：

  ```java
  package Cache;
  
  import javax.servlet.http.HttpSession;
  import java.util.HashMap;
  import java.util.Map;
  
  public class LoginCache {
      //创建一个静态对象，使得不同用户登录时获取的LoginCache对象都是同一个
      private static LoginCache instance=new LoginCache();
      //创建用户名和sessionid的映射
      private Map<String,String> loginUserSession=new HashMap<>();
      //创建sessionid和session对象的映射
      private Map<String, HttpSession> loginSession=new HashMap<>();
      //获取LoginCache静态对象
      public static LoginCache getInstance() {
          return instance;
      }
      public String getSessionIdByUsername(String username){
          return loginUserSession.get(username);
      }
      public HttpSession getSessionBySessionId(String sessionid){
          return loginSession.get(sessionid);
      }
      public void setSessionIdByUsername(String username,String sessionid){
          loginUserSession.put(username,sessionid);
      }
      public void setSessionBySessionId(String sessionid,HttpSession session){
          loginSession.put(sessionid,session);
      }
  }
  ```

- 监听器代码

  ```java
  package Listener;
  import Cache.LoginCache;
  import javax.servlet.annotation.WebListener;
  import javax.servlet.http.HttpSession;
  import javax.servlet.http.HttpSessionAttributeListener;
  import javax.servlet.http.HttpSessionBindingEvent;
  
  @WebListener()
  //采用HttpSessionAttributeListener监听器，来实现对HttpSession对象的属性的监听
  public class MyListener implements HttpSessionAttributeListener {
  
      public MyListener() {
      }
      @Override
      public void attributeAdded(HttpSessionBindingEvent se) {
          //获取添加的属性名
          String attrName=se.getName();
          //当被添加的属性名为username，说明有用户正在尝试登录
          if(attrName.equals("username")){
              //获取账号
              String attrValue= (String) se.getValue();
              //获取LoginCache对象
              LoginCache loginCache=LoginCache.getInstance();
              //查询该账号对应的sessionid
              String sessionId=loginCache.getSessionIdByUsername(attrValue);
              //若sessionid不为空，则说明其他用户正在使用该账号
              if(sessionId != null){
                  //获取当前正在使用该账号的用户的Session对象
                  HttpSession session=loginCache.getSessionBySessionId(sessionId);
                  //将其Session对象销毁，即让当前在线用户强制注销
                  session.invalidate();
              }
              //若sessionid为空，则表示当前无人使用该账号
              else {
                  //将用户的信息加入映射
                  loginCache.setSessionIdByUsername(attrValue,se.getSession().getId());
                  loginCache.setSessionBySessionId(se.getSession().getId(),se.getSession());
              }
          }
      }
  }
  ```

- 过滤器代码

  过滤器和监听器的搭配才能实现用户强制注销的效果

  ```javascript
  package Filter;
  
  import java.io.IOException;
  
  import javax.servlet.Filter;
  import javax.servlet.FilterChain;
  import javax.servlet.FilterConfig;
  import javax.servlet.ServletException;
  import javax.servlet.ServletRequest;
  import javax.servlet.ServletResponse;
  import javax.servlet.annotation.WebFilter;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  
  @WebFilter(filterName = "SessionFilter",urlPatterns = "/main.jsp")
  public class SessionFilter implements Filter {
  
     @Override
     public void destroy() {
  
     }
  
     @Override
     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
           throws IOException, ServletException {
  
        HttpServletRequest hrequest = (HttpServletRequest) request;// 涉及到HTTP请求处理，转型处理
        HttpServletResponse hresponse = (HttpServletResponse) response;// 涉及到HTTP请求处理，转型处理
  
        String loginUser = (String) hrequest.getSession().getAttribute("username");// 判断用户是否完成了登录操作，session中是否存储用户名
  	
        if (loginUser == null) {
           //用户被强制注销时，也会进入未登录状态，从而被强制跳转到登录页面
           hresponse.sendRedirect(hrequest.getContextPath() + "/uniq.jsp?flag=1");// 未登录，系统强制重定向至登录页面
           return;
        } else {
           chain.doFilter(hrequest, hresponse);
           return;
        }
  
     }
  
     @Override
     public void init(FilterConfig config) throws ServletException {
  
     }
  
  }
  ```

- Servlet代码

  ```java
  package Servlet;
  
  import javax.servlet.ServletException;
  import javax.servlet.annotation.WebServlet;
  import javax.servlet.http.HttpServlet;
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  
  @WebServlet(name = "LoginServlet",urlPatterns = "/LoginServlet")
  public class LoginServlet extends HttpServlet {
      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
          String un=request.getParameter("username");
          String pw=request.getParameter("password");
          if(un.equals("potato")&&pw.equals("123456")){
              //当用户名密码正确，就将用户名储存到Session域中，此时会触发监听器
              request.getSession().setAttribute("username",un);
              response.sendRedirect("main.jsp");
          }
      }
  
      protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  
      }
  }
  ```

## 13.验证码

### 13.1字母数字混合验证码生成

```java
package captcha;

import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class VerifyCode {
    public static String drawCode(HttpServletResponse httpServletResponse) throws IOException {
        //创建一个StringBuilde对象，即可变字符串对象
        //普通的String对象不可变
        //当StringBuilde对象获得最终的字符串时，可调用toString方法转变为String对象
        StringBuilder stringBuilder=new StringBuilder();
        //循环四次，生成4个字母和数字的混合验证码
        for(int i=0;i<4;i++){
            //将每次随机生成的字符拼接
            stringBuilder.append(randomChar());
        }
        //调用StringBuilde对象的toString()方法，获得验证码
        String code=stringBuilder.toString();
        //开始绘制验证码的图片
        //设置验证码图片的宽高
        int WIDTH=120,HEIGHT=25;
        //创建一个BufferedImage对象，用于构造一个预定义的图像类型，该图像会储存在内存的图像缓冲区，可供用户操作绘制
        //提供参数，用于指定图像宽高和图像类型，BufferedImage.TYPE_3BYTE_BGR表示图像的类型
        BufferedImage bufferedImage=new BufferedImage(WIDTH,HEIGHT,BufferedImage.TYPE_3BYTE_BGR);
        //通过BufferedImage对象的createGraphics()方法，创建一个Graphics2D对象，用于实现对该图像的绘制
        //Graphics2D对象相当于画笔
        Graphics2D graphics2D=bufferedImage.createGraphics();
        //创建字体对象
        Font font=new Font("微软雅黑", Font.PLAIN,20);
        //画笔以该字体进行绘制
        graphics2D.setFont(font);
        //设置画笔的颜色
        graphics2D.setColor(new Color(0,0,0));
        //设置图像的背景色
        graphics2D.setBackground(new Color(226,226,240));
        //使用当前图像的背景色来填充清除指定的矩形，即绘制一个带背景色的矩形
        //四个参数表示矩形对角线的两个坐标
        graphics2D.clearRect(0,0,WIDTH,HEIGHT);
        //获得字体的上下文
        FontRenderContext fontRenderContext=graphics2D.getFontRenderContext();
        //FontRenderContext的getStringBounds方法可以获取指定文本的逻辑边界，即获取验证码文本宽高等信息
        //getStringBounds方法将会使用窗体矩形来封装指定文本
        Rectangle2D rectangle2D=font.getStringBounds(code,fontRenderContext);
        //getWidth()方法获取窗体矩形的宽度
        double x= (WIDTH-rectangle2D.getWidth())/2;
        //getHeight()方法获取窗体矩形的高度
        double y= (HEIGHT-rectangle2D.getHeight())/2;
        //getY()方法获取窗体矩形左上角的Y坐标
        double ascent=rectangle2D.getY();
        //获取文本左上角在图像中的Y坐标
        double baseY=y-ascent;
        //开始绘制文本
        //code表示要绘制的文本，x和baseY表示开始绘制文本的坐标
        //绘制出的文本将会在图像中呈现居中效果
        graphics2D.drawString(code,(int)x,(int)baseY);
        //Graphics2D对象的dispose方法，表示开始处理上述的Graphics2D对象的绘制操作，然后释放资源
        graphics2D.dispose();
        //ImageIO的write方法用于将BufferedImage对象创建的图像以指定格式写入输出流中
        //此处以jpg的格式将图像写入HttpServletResponse对象的输出流
        ImageIO.write(bufferedImage,"jpg",httpServletResponse.getOutputStream());
        //将HttpServletResponse对象的缓冲区输出到网页上
        httpServletResponse.flushBuffer();
        //关闭HttpServletResponse对象的输出流
        httpServletResponse.getOutputStream().close();
        //返回生成的验证码，用于后端校验
        return code;
    }	
    //用于生成随机字符
    private static char randomChar(){
        //创建随机对象
        Random random=new Random();
        //包含26个字母和数字
        String charLib="QWERTYUIOPASDFGHJKLZXCVBNM1234567890";
        //通过随机对象，随机获取26个字母和数字中的一个
        return charLib.charAt(random.nextInt(charLib.length()));
    }
}

```

### 13.2算术验证码生成

```java
package captcha;
import javax.imageio.ImageIO;
import javax.servlet.http.HttpServletResponse;
import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.util.Random;

public class VerifyCode {
    public static String drawArithmeticCode(HttpServletResponse httpServletResponse) throws IOException {
        //指定生成验证码的图片宽高
        int WIDTH=130,HEIGHT=30;
        BufferedImage bufferedImage=new BufferedImage(WIDTH,HEIGHT,BufferedImage.TYPE_INT_RGB);
        Graphics2D graphics2D=bufferedImage.createGraphics();
        //设置背景颜色为随机数值
        graphics2D.setBackground(randomColor(240,250));
        graphics2D.setFont(new Font("微软雅黑", Font.PLAIN,22));
        //Graphics2D对象的fillRect方法，用于填充指定矩形
        //前两个参数为矩形的左上角坐标，后两个参数为矩形的宽高
        graphics2D.fillRect(0,0,WIDTH,HEIGHT);
        Random random=new Random();
        //设置画笔颜色为随机数值
        graphics2D.setColor(randomColor(180,230));
        //设置验证码的干扰线
        //此处生成位置随机的50根干扰线条
        for(int i=0;i<50;i++){
            //线条起始点的x坐标
            int x=random.nextInt(WIDTH);
            //线条起始点的y坐标
            int y=random.nextInt(HEIGHT);
            //线条终止点的x坐标
            int x1=random.nextInt(60);
            //线条终止点的y坐标
            int y1=random.nextInt(60);
            //drawLine方法用于绘制线条
            graphics2D.drawLine(x,y,x1,y1);
        }
        //生成两个1-100的随机数
        int num1=(int)(Math.random()*100+1);
        int num2=(int)(Math.random()*100+1);
        //生成0-3的随机数
        int operator=random.nextInt(3);
        //运算符
        String operatorStr;
        //生成的算术验证码的运算结果
        int result;
        switch (operator){
            //若operator为0
            case 0:
                //运算符为+
                operatorStr="+";
                //保存运算结果
                result=num1+num2;
                break;
            //若operator为1    
            case 1:
                //运算符为-
                operatorStr="-";
                //保存运算结果
                result=num1-num2;
                break;
            //若operator为2    
            case 2:
                //运算符为*
                operatorStr="*";
                //保存运算结果
                result=num1*num2;
                break;
            default:
                throw new IllegalStateException("Unexpected value: " + operator);
        }
        //生成算术字符串
        String code=num1+" "+operatorStr+" "+num2+" "+"="+" "+"?";
        graphics2D.setColor(new Color(20+random.nextInt(110),20+random.nextInt(110),20+random.nextInt(110)));
        //绘制算术字符串
        //在图片的(5,25)坐标开始绘制
        graphics2D.drawString(code,5,25);
        //执行上述画笔操作，并释放资源
        graphics2D.dispose();
        ImageIO.write(bufferedImage,"jpg",httpServletResponse.getOutputStream());
        httpServletResponse.flushBuffer();
        httpServletResponse.getOutputStream().close();
        //将结果转换为字符串返回，供后端校验
        return String.valueOf(result);

    }
    //生成指定范围内的颜色
    private static Color randomColor(int fc,int bc){
        Random random=new Random();
        if(fc>255){
            fc=255;
        }
        if(bc>255){
            bc=255;
        }
        int r=fc+random.nextInt(bc-fc);
        int g=fc+random.nextInt(bc-fc);
        int b=fc+random.nextInt(bc-fc);
        return new Color(r,g,b);
    }
}
```
