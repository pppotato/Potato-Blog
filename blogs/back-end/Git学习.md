---
title: Git学习
date: 2020-12-11
categories:
- Back-End
tags:
- Git
---

## 1.Git简介

Git是一个**分布式**的**版本控制工具**

- 分布式与集中式

  - 集中式

    集中式的版本控制工具，会有一个远程的中央服务器来存储版本库，任何一个客户端想要使用该版本控制工具，都必须先**联网**从中央服务器中获取最新的版本库才能正常工作，工作完毕后再推送给远程中央服务器

  - 分布式

    分布式的版本控制工具，没有中央服务器的概念，任何一个客户端在本地都会存储完整的版本库，这样就省去了联网的操作

- 版本控制工具

  一个版本控制工具应该具备以下特性：

  - 协同修改

    多人并行不悖的修改服务器端的同一个文件

  - 数据备份

    不仅保存目录和文件的当前状态，还能够保存每一个提交过的历史状态

  - 版本管理

    在保存每一个版本的文件信息的时候要做到不保存重复数据，以节约存储空间，提高运行效率。这方面 Git采取了文件系统快照的方式

  - 权限控制

    对团队中参与开发的人员进行权限控制

    对团队外开发者贡献的代码进行审核(Git 独有)

  - 历史记录

    查看修改人、修改时间、修改内容、日志信息

    将本地文件恢复到某一个历史状态

  - 分支管理

    允许开发团队在工作过程中多条生产线同时推进任务，进一步提高效率

## 2.Git结构

Git整体分为三个部分：

- 本地库

  用于保存项目的历史版本

- 暂存区

  用于临时存储将要提交到本地库的项目版本

- 工作区

  用于编写开发项目

![image-20211205085112819](/static/img/image-20211205085112819.png)

被Git所管理的项目，其文件可能存在于这三种状态：

- `Untracked files`

  文件未被追踪，表示工作区中该文件未添加至暂存区中被Git管理。比如工作区新建文件

- `Changes to be committed`

  文件已暂存，表示工作区中该文件已被添加至暂存区中被Git管理。比如使用`git add`命令将该文件添加至暂存区

- `Changes not staged for commit`

  文件被修改但未被暂存，表示工作区中被Git管理（即已经添加至暂存区）的文件在修改完毕后，未重新添加至暂存区。比如在工作区修改文件后，还没有使用`git add`命令将修改后的文件添加至暂存区进行更新

## 3.Git本地操作

### 3.1本地库初始化

- 指令：`git init`

  在当前目录下初始化一个git本地库并生成一个`.git`目录，该目录用于管理跟踪本地库，里面存放的是和本地库相关的子目录和文件

- 实操

  ![image-20211205085508991](/static/img/image-20211205085508991.png)

### 3.2设置签名

- 签名形式

  一个签名包含两个部分：

  - user.name
  - user.email

- 签名作用

  用于区分不同开发人员的身份

- 指令

  - 项目级别/仓库级别

    仅在当前本地库有效

    - `git config user.name [username]`
    - `git config user.email [email]`

    该设置的信息保存在当前项目的`.git/config`文件

  - 系统用户级别

    登录当前操作系统的用户范围

    - `git config --global user.name [username]`
    - `git config --global user.email[email]`

    该设置的信息保存在系统用户目录的`.gitconfig`文件

  - 级别优先级

    - 项目级别优先于系统用户级别，二者都有时采用项目级别的签名 
    - 如果只有系统用户级别的签名，就以系统用户级别的签名为准 
    - 二者都没有,Git将不允许你执行相关操作

- 实操

  - 项目级别/仓库级别

    ![image-20211205093032282](/static/img/image-20211205093032282.png)

  - 系统用户级别

    ![image-20211205093140434](/static/img/image-20211205093140434.png)

### 3.3状态查看

- 指令：`git status`

  查看工作区和暂存区的状态信息

- 实操

  ![image-20211205091757811](/static/img/image-20211205091757811.png)

  - `On branch master`

    表示当前处于`master`分支上

  - `No commits yet`

    表示本地库中无内容，还没有任何项目被提交到本地库

  - `nothing to commit`

    表示暂存区中无内容，还没有任何项目被添加到暂存区

### 3.4添加内容至暂存区

- 指令

  - `git add [file1] [file2] ...`

    添加一个或多个文件至暂存区

  - `git add [dir]`
    添加指定目录到暂存区，包括其子目录

  - `git add .`
    添加当前目录下的所有内容至暂存区

- 实操

  ![image-20211205093809203](/static/img/image-20211205093809203.png)

  - 在工作区新建了一个`addFile.txt`文件后，使用`git status`查看状态信息会提示如下信息

    ```cmd
    #当前目录下出现了未追踪的文件
    Untracked files:
      #可以使用git add <file>将该文件添加至暂存区
      (use "git add <file>..." to include in what will be committed)
            addFile.txt
    ```

  - 在使用`git add <file>`指令将`addFile.txt`添加至暂存区后，使用`git status`查看状态信息会提示如下信息

    ```cmd
    #已暂存
    Changes to be committed:
      #可以使用git rm --cached <file>将该文件从暂存区中删除
      (use "git rm --cached <file>..." to unstage)
            new file:   addFile.txt
    ```

### 3.5提交内容至本地库

- 指令

  - `git commit -m [message]`

    将暂存区中内容提交至本地库，`message`表示此次提交的备注信息（**备注信息必须有，才能提交**）

  - `git commit [file1] [file2] ... -m [message] `

    提交暂存区中的指定文件至本地库

  - `git commit -a`

    对于已经被添加至暂存区的文件，在工作区中被修改后，可以直接使用该指令，即可将工作区中的修改同步至暂存区并提交至本地库，无需再执行`git add`指令更新到暂存区

- 实操

  ![image-20211205151013241](/static/img/image-20211205151013241.png)

  - 第一次提交`addFile.txt`文件后，使用`git status`查看状态信息会提示如下信息

    ```cmd
    On branch master
    #表示暂存区中无内容，工作树干净
    nothing to commit, working tree clean
    ```

  - 然后对`addFile.txt`文件进行修改后，使用`git status`查看状态信息会提示如下信息

    ```cmd
    On branch master
    #文件被修改但未被暂存
    Changes not staged for commit:
      #使用git add <file>指令将工作区中修改后的文件更新至暂存区
      (use "git add <file>..." to update what will be committed)
      #使用git restore <file>指令将工作区中的修改撤销
      (use "git restore <file>..." to discard changes in working directory)
            modified:   addFile.txt
    #使用git add和git commit或者git commit -a将工作区中修改同步至暂存区并提交到本地库
    no changes added to commit (use "git add" and/or "git commit -a")
    ```

### 3.6查看历史提交的版本信息

- 指令

  - `git log`

    只能显示当前版本及之前提交过的所有版本信息

  - `git reflog`

    显示所有的操作记录，包括提交和回退

- 参数

  - `--pretty=oneline`

    以漂亮的格式将每条提交的历史记录只显示一行

  - `--oneline`

    每条提交的历史记录只显示一行

- 实操

  ![image-20211205155843250](/static/img/image-20211205155843250.png)

  - 使用`git log`和`git reflog`指令显示有两条记录
  - 然后使用`git reset --hard 089bc44`将当前版本向前回退一次，此时`git log`指令只能显示一条记录，即当前版本的前一个版本，而`git reflog`指令显示有三条信息，即新增了一条回退的操作记录

### 3.7版本的前进和后退

- 本质

  Git有一个`HEAD`指针指向当前分支指针，而当前分支指针会指向当前的版本，可以通过移动该`HEAD`指针来实现版本的前进和后退

- 指令

  - 基于索引值操作

    Git中每一个版本都会用一个哈希索引值来标识

    `git reset --hard [哈希索引值]`

  - 基于`^`操作

    只能后退

    `git reset --hard HEAD^`（一个`^`表示后退一步，n个`^`表示后退n步）

  - 基于`~`操作

    只能后退

    `git reset --hard HEAD~[n]`（n表示要后退的步数）

- ` git reset`命令三个参数对比

  - `--soft`

    - 仅在本地库中移动`HEAD`指针

    ![image-20211205172734524](/static/img/image-20211205172734524.png)

  - `--mixed`

    - 在本地库中移动`HEAD`指针
    - 同时将移动后的版本信息同步到暂存区

    ![image-20211205172653820](/static/img/image-20211205172653820.png)

  - `--hard`

    - 在本地库中移动`HEAD`指针
    - 同时移动后的版本信息同步到暂存区和工作区

- 实操

  **大前提：文件还存在的版本已经被提交至本地库**

  工作区永久删除文件后找回：

  ![image-20211205190952222](/static/img/image-20211205190952222.png)

  在工作区文件被删除后，使用`git reset --hard [哈希索引值]`回退到文件还存在的版本

### 3.8比较文件差异

- 指令

  - `git diff [file]` 

    查看工作区与暂存区的差异

  - `git diff --cached [file]` 

    查看暂存区与本地库的差异

  - `git diff HEAD [file]`

    查看工作区与本地库的差异

- 实操

  - 查看工作区与暂存区的差异

    ![image-20211205193527280](/static/img/image-20211205193527280.png)

  - 查看暂存区与本地库的差异

    ![image-20211205193652107](/static/img/image-20211205193652107.png)

  - 查看工作区与本地库的差异

    ![image-20211205193604234](/static/img/image-20211205193604234.png)

## 4.Git分支

### 4.1概述

几乎所有的版本控制系统都以某种形式支持分支，使用分支意味着你在开发一个项目时可以多条线同时推进，每一个分支都是独立的，可以用于开发不同的功能

![image-20211205200435927](/static/img/image-20211205200435927.png)

以上图为例：

- 项目的主分支master，同时还有两条从主分支抽离的从分支feature_blue和feature_game
- **这两条从分支都是主分支master在创建这两条从分支的时间节点的一个快照**
- 由于分支都是独立的，即使从分支出现了无法修复的bug，也不会影响到主分支
- 从分支在开发完毕后也可以合并到主分支
- 如果主分支出现了bug，一般会创建一个临时分支hot_fix用于修复bug，在修复完毕后再合并到主分支

### 4.2分支操作

#### 4.2.1查看当前所在分支

- 指令

  `git status`

- 实操

  ![image-20211205201557088](/static/img/image-20211205201557088.png)

#### 4.2.2查看所有分支

- 指令

  `git branch -v`

- 实操

  ![image-20211205201812818](/static/img/image-20211205201812818.png)

#### 4.2.3创建分支

- 指令

  `git branch [分支名]`

- 实操

  ![image-20211205201928868](/static/img/image-20211205201928868.png)

#### 4.2.4切换分支

- 指令

  `git checkout [分支名]`

- 实操

  ![image-20211205202032506](/static/img/image-20211205202032506.png)

#### 4.2.5合并分支

- 指令

  `git merge [要合并的分支名]`

- 合并冲突

  - 产生原因

    两条分支都对同一个文件的同一个位置进行了修改并提交，并且修改的内容不同，那么这两条分支在合并时就会产生冲突

  - 解决

    Git分支合并产生冲突时，需要我们进入冲突的文件中手动修改

- 实操

  将main分支合并到master分支并解决合并冲突：

  - master分支下的`addFile.txt`

    ![image-20211205212012768](/static/img/image-20211205212012768.png)

  - 对其修改并提交

    ![image-20211205212146549](/static/img/image-20211205212146549.png)

  - 切换至main分支下的`addFile.txt`

    ![image-20211205212442042](/static/img/image-20211205212442042.png)

  - 对其修改并提交

    ![image-20211205212607911](/static/img/image-20211205212607911.png)

  - 切换回master分支下，使用`git merge`指令将main分支合并，冲突产生

    ![image-20211205212724876](/static/img/image-20211205212724876.png)

  - 进入产生冲突的文件中可以看到Git给出的提示

    ```cmd
    Hello,World!
    aaaaaaaaaaa
    bbbbbbbbbbb
    #HEAD指针指向的分支所作的修改    
    <<<<<<< HEAD
    =======
    #main分支所作的修改
    cccccccccccfffffff
    >>>>>>> main
    ```

  - 手动修改文件解决冲突，然后用`git commit -a`指令结束合并操作

    ![image-20211205213458395](/static/img/image-20211205213458395.png)

#### 4.2.6删除分支

- 指令

  - `git branch -d [分支名]`
  - `git branch -D [分支名]`（强制删除）

- 实操

  ![image-20211206095145804](/static/img/image-20211206095145804.png)

## 5.Git基本原理

### 5.1哈希算法

哈希是一个系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点： 

- 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定。 

- 哈希算法确定，输入数据确定，输出数据能够保证不变 

- 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 

- 哈希算法不可逆

Git底层采用的是SHA-1哈希算法，通过该算法能够实时保持数据的完整性，其原理如下：

![image-20211206223646885](/static/img/image-20211206223646885.png)

### 5.2Git对象

Git内部有三种对象，对于每一个对象都会用SHA-1算法计算一个密文作为其索引

- 数据对象

  Git中的数据对象相当于文件系统中的文件，不同的是，数据对象只存文件的内容，而文件名则由树对象保存

  ![image-20211206224532210](/static/img/image-20211206224532210.png)

- 树对象

  Git中的树对象相当于文件系统中的文件夹

  ![image-20211206224750124](/static/img/image-20211206224750124.png)

- 提交对象

  Git中的提交对象相当于是树对象的一层包装，里面包含了提交时间，提交作者，注释等信息，更重要的是里面包含了父提交的索引（父提交，即当前提交的上一次提交），由此便能形成一条历史版本链

  ![image-20211206225226183](/static/img/image-20211206225226183.png)

### 5.3版本控制机制

- Git采用快照的机制来对每一个版本进行备份

  **Git本质上是一个内容寻址的文件系统，其次才是一个版本控制系统**，所谓内容寻址，即根据文件内容的哈希索引来定位文件，这就意味着同样内容的文件，在这个文件系统中会指向同一个位置，不会重复存储，减少了冗余

- Git的每一个提交对象中都保存了父提交的哈希索引，从而形成一条历史版本链

![image-20211206233541409](/static/img/image-20211206233541409.png)

### 5.4分支管理机制

**Git分支本质上是一个指向提交对象的指针**

- 创建分支原理

  实质上就是新建了一个分支指针指向了当前分支所指向的提交对象

  示例：

  - 新建分支testing

    ![image-20211206234525469](/static/img/image-20211206234525469.png)

- 切换分支原理

  Git中有一个HEAD指针指向当前分支对应的指针，所以切换分支实质上就是让HEAD指针指向不同的分支指针

  示例：

  - 切换至分支testing

    ![image-20211206234900679](/static/img/image-20211206234900679.png)

  - 在分支testing上提交一个新版本，然后再切换回master分支提交一个新版本

    ![image-20211206235001456](/static/img/image-20211206235001456.png)

    ![image-20211206235032617](/static/img/image-20211206235032617.png)

    ![image-20211206235147784](/static/img/image-20211206235147784.png)

## 6.Git远程操作

为了实现多人协同开发，Git还需要拥有一个远程库，为此就需要借助GitHub、Gitee等代码托管中心

- 本地库与远程库的交互方式

  - 团队内部多人协同开发

    ![image-20211206113906735](/static/img/image-20211206113906735.png)

  - 跨团队多人协同开发

    ![image-20211206143504129](/static/img/image-20211206143504129.png)

    

### 6.1GitHub

#### 6.1.1创建仓库（作为Git的远程库）

![image-20211206101516995](/static/img/image-20211206101516995.png)

![image-20211206102819391](/static/img/image-20211206102819391.png)

- 关于开源证书的选择

  ![image-20211206103011961](/static/img/image-20211206103011961.png)

#### 6.2设置SSH免密登录

- 连接方式：

  Git本地可以通过两种方式连接GitHub远程库

  - HTTPS

    每次连接都需要输入GitHub的账号和密码，从而来验证提交者的合法身份

  - SSH

    在本地机器上通过Git生成一对公钥和私钥，将公钥配置到GitHub账号里，私钥留在本地机器里，这样每次连接，无须我们手动输入账号和密码，Git会使用私钥和Github里的公钥做比对，从而来验证提交机器的合法身份

- 配置SSH免密登录

  - 在本地机器上使用Git指令生成一个存放公钥和私钥的.ssh目录

    ![image-20211206105405825](/static/img/image-20211206105405825.png)

    - 进入.ssh目录查看id_rsa.pub文件获取公钥

      ![image-20211206105801845](/static/img/image-20211206105801845.png)

    - 在GitHub账号的Settings中配置公钥

      ![image-20211206110148100](/static/img/image-20211206110148100.png)

#### 6.3邀请他人加入团队

在远程库的Settings配置中可以进行配置

![image-20211206115455117](/static/img/image-20211206115455117.png)



### 6.2查看远程库

- 指令：`git remote -v`

  查看Git本地添加的所有远程库

- 实操

  ![image-20211206111551039](/static/img/image-20211206111551039.png)

### 6.3添加远程库

- 指令：`git remote add [别名] [远程库地址]`

  通过远程库地址将Git本地与远程库关联起来，并为该远程地址起一个别名，方便后续使用

- 实操

  ![image-20211206111727644](/static/img/image-20211206111727644.png)

### 6.4推送操作

- 指令：`git push [别名] [分支名]`

  通过本地保存的远程库地址的别名，将相应的分支推送到远程库

- 实操

  ![image-20211206112314810](/static/img/image-20211206112314810.png)

### 6.5克隆操作

- 指令：`git clone [远程地址]`

  通过他人远程库的地址，可以将其远程库中的项目克隆到本地，同时会自动初始化本地库和添加一个该远程库地址的别名

- 实操

  ![image-20211206114532778](/static/img/image-20211206114532778.png)

### 6.6拉取操作

- 指令：`git fetch [别名] [远程分支名]`  

  通过本地保存的远程库地址的别名，将远程库对应分支的内容拉取到本地并保存在`别名/远程分支名`分支上，但是该操作并不会影响到工作区文件，仅仅是拉取到本地供用户查看

- 实操

  ![image-20211206134239979](/static/img/image-20211206134239979.png)

### 6.7合并操作

- 指令：`git merge [别名]/[远程分支名]`

  合并拉取下来的远程分支到本地

- 实操

  ![image-20211206134723662](/static/img/image-20211206134723662.png)

### 6.8拉取合并操作

- 指令：`git pull [别名] [远程分支名]:[本地分支名]`（如果合并到当前分支，则可以省略`:`及后面部分）

  相当于`fetch`和`merge`指令的结合

- 实操

  ![image-20211206135917264](/static/img/image-20211206135917264.png)

### 6.9推送冲突

- 产生原因

  多人协同开发时，大家都克隆同一条远程分支到本地，假设此时一名成员将开发好的内容推送至远程分支，导致远程分支的版本更新，那么另一名成员再开发完成后执行推送操作，则会产生冲突

- 冲突表现

  假设此时其他人修改了远程库分支，导致本地库的分支与远程库的分支版本不一致

  ![image-20211206141631264](/static/img/image-20211206141631264.png)

- 冲突解决

  在推送操作前，执行`git pull`/`git fetch`+`git merge`指令将远程库的更新拉取到本地进行合并，来同步远程库与本地库版的分支版本

- 实操

  ![image-20211206141911555](/static/img/image-20211206141911555.png)
